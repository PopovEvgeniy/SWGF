<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1251">
    <title>Programmer reference</title>
  </head>
  <body>
    <p> </p>
    <p> </p>
    <p> <big> </big> </p>
    <div>
      <div style="text-align: center;"><big>Simple windows game framework:
          Programmer reference</big></div>
    </div>
    <big><br>
      <br>
      Table of contents</big>
    <ul id="mozToc">
      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
      <li><a href="#mozTocId665557">Part 1. Welcome to Simple windows game
          framework</a>
        <ul>
          <li><a href="#mozTocId471990">Chapter 1. Introduction</a></li>
          <li><a href="#mozTocId85003">Chapter 2. A special thanks</a></li>
          <li><a href="#mozTocId810132">Chapter 3. License</a></li>
          <li><a href="#mozTocId336772">Chapter 4. System requirements</a></li>
          <li><a href="#mozTocId928115">Chapter 5. Trouble guide</a></li>
          <li><a href="#mozTocId491993">Chapter 6. Compilers</a></li>
          <li><a href="#mozTocId56069">Chapter 7. Platform specific notes</a></li>
          <li><a href="#mozTocId914689">Chapter 8. The engine name–space</a></li>
          <li><a href="#mozTocId417277">Chapter 9. Custom date types</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId859712">Part 2. Base things</a>
        <ul>
          <li><a href="#mozTocId312970">Chapter 1. Coordinate system</a></li>
          <li><a href="#mozTocId544184">Chapter 2. A game cycle</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId760374">Part 3. Graphics</a>
        <ul>
          <li><a href="#mozTocId182571">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId552078">Chapter 2. Base graphics subsystem</a></li>
          <li><a href="#mozTocId289525">Chapter 3. Picture subsystem</a></li>
          <li><a href="#mozTocId501089">Chapter 4. Animation subsystem</a></li>
          <li><a href="#mozTocId904725">Chapter 5. Image kind</a></li>
          <li><a href="#mozTocId738557">Chapter 6. Background</a></li>
          <li><a href="#mozTocId515277">Chapter 7. Static background</a></li>
          <li><a href="#mozTocId309905">Chapter 8. Base sprite subsystem</a></li>
          <li><a href="#mozTocId662651">Chapter 9. Ordinary sprites</a></li>
          <li><a href="#mozTocId477705">Chapter 10. Static sprites</a></li>
          <li><a href="#mozTocId146800">Chapter 11. Sprite sheet</a></li>
          <li><a href="#mozTocId752257">Chapter 12. Text</a></li>
          <li><a href="#mozTocId67980">Chapter 13. Loading images</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId99230">Part 4. Transformation</a>
        <ul>
          <li><a href="#mozTocId248613">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId462005">Chapter 2. Cartesian coordinates and
              screen coordinates</a></li>
          <li><a href="#mozTocId251950">Chapter 3. Cartesian coordinates and
              isometric coordinates</a></li>
          <li><a href="#mozTocId143616">Chapter 4. Isometric level</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId64443">Part 5. Common things</a>
        <ul>
          <li><a href="#mozTocId597525">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId853711">Chapter 2. Abnormal program termination</a></li>
          <li><a href="#mozTocId656377">Chapter 3. Timer</a></li>
          <li><a href="#mozTocId381935">Chapter 4. Collision</a></li>
          <li><a href="#mozTocId828077">Chapter 5. Tile–map</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId611237">Part 6. Other important things</a>
        <ul>
          <li><a href="#mozTocId648026">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId909723">Chapter 2. Memory</a></li>
          <li><a href="#mozTocId950985">Chapter 3. Audio</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId209024">Part 7. Misc</a>
        <ul>
          <li><a href="#mozTocId608755">Chapter 1. File system</a></li>
          <li><a href="#mozTocId59386">Chapter 2. Tools</a></li>
          <li><a href="#mozTocId573582">Chapter 3. Resource manager</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId590919">Part 8. Binary files</a>
        <ul>
          <li><a href="#mozTocId200879">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId961921">Chapter 2. Base binary file subsystem</a></li>
          <li><a href="#mozTocId424835">Chapter 3. File reader</a></li>
          <li><a href="#mozTocId511135">Chapter 4. File writer</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId291572">Part 9. Input</a>
        <ul>
          <li><a href="#mozTocId783369">Chapter 1. The sub–namespace</a></li>
          <li><a href="#mozTocId685403">Chapter 2. Keyboard</a></li>
          <li><a href="#mozTocId686993">Chapter 3. Mouse</a></li>
          <li><a href="#mozTocId861609">Chapter 4. Game–pad</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId309127">Part 10. Internal details of the engine
          subsystems</a>
        <ul>
          <li><a href="#mozTocId383177">Chapter 1. A few words for a curious
              programmer</a></li>
          <li><a href="#mozTocId318160">Chapter 2. Internal classes</a></li>
          <li><a href="#mozTocId293644">Chapter 3. Base graphics subsystem</a></li>
          <li><a href="#mozTocId472209">Chapter 4. Game–pad</a></li>
          <li><a href="#mozTocId804583">Chapter 5. Input</a></li>
          <li><a href="#mozTocId692266">Chapter 6. Audio</a></li>
        </ul>
      </li>
      <li><a href="#mozTocId78453">Version history</a></li>
    </ul>
    <big> </big>
    <h1><a name="mozTocId665557" class="mozTocH1"></a><big>Part 1. Welcome to
        Simple windows game framework</big></h1>
    <big> </big>
    <h2><a name="mozTocId471990" class="mozTocH2"></a><big>Chapter 1.
        Introduction</big></h2>
    <big> <span style="text-decoration: underline;"> Introduction</span><br>
      <br>
      Hello from Russia. My name is Popov Evgeniy Alekseyevich. I am the
      individual programmer. I enjoy creating software. I also like old–school
      video games. Do you want to develop video games for Microsoft Windows? You
      need a good game engine for doing it. I made my own engine. I hope that my
      C++ game engine will be useful for many programmers.<br>
      <br>
      <span style="text-decoration: underline;"> Features</span><br>
      <br>
      Let me show the engine features. Let's go. </big>
    <ul>
      <li><big>Open source code.</big></li>
      <li><big>Easy to use object–orientated design.</big></li>
      <li><big>Very fast.</big></li>
      <li><big>Minimum external dependencies: only DirectX, OPENGL and standard
          Windows API libraries.</big></li>
      <li><big>Don't need to link a main program with the engine binary file.
          The engine is just source code files with all engine codes.</big></li>
    </ul>
    <big><br style="text-decoration: underline;">
      <span style="text-decoration: underline;"> Installation</span><br>
      <br>
      How install this engine? Follow these steps:<br>
      <br>
      Copy these files to your project directory: </big>
    <ul>
      <li><big>SWGF.h</big></li>
      <li><big>SWGF.cpp</big></li>
    </ul>
    <big><br>
      Add it to your project.<br>
      Add this directive to your code: #include "SWGF.h"<br>
      Yes. This is really all that you need to do.<br>
      <br>
      <span style="text-decoration: underline;"> Feedback</span><br>
      <br>
      Send me <a href="mailto:tuzik87@inbox.ru">e–mail</a> if you want contact
      with me. </big>
    <h2><a name="mozTocId85003" class="mozTocH2"></a><big>Chapter 2. A special
        thanks</big></h2>
    <big> I want to say «Big thanks for technical consultation» to these
      peoples: </big>
    <ul>
      <li><a href="https://github.com/dmitrysmagin"><big>Dmitry Smagin</big></a></li>
      <li><a href="https://bsg.org.ua"><big>Pavel Samko</big></a></li>
      <li><a href="https://github.com/EXL"><big>EXL</big></a></li>
      <li><a href="http://www.almost-university.com"><big>Vladimir Mozhenkov</big></a></li>
      <li><a href="https://vk.com/strong666"><big>Vitaliy Molochkov</big></a></li>
      <li><a href="mailto:eyegem@mail.ru"><big>Evgenia Germanova</big></a></li>
      <li><big>DDMZ</big></li>
      <li><big>Anastasiya</big></li>
    </ul>
    <big><br>
      Also thanks to PVS–Studio team for <a href="https://www.viva64.com/en/b/0614/">free
        license</a>. </big>
    <h2><a name="mozTocId810132" class="mozTocH2"></a><big>Chapter 3. License</big></h2>
    <big> <span style="text-decoration: underline;"> Simple windows game
        framework license</span><br>
      <br>
      Copyright (C) 2015 – 2024 Popov Evgeniy Alekseyevich<br>
      <br>
      This software is provided 'as–is', without any express or implied<br>
      warranty. In no event will the authors be held liable for any damages<br>
      arising from the use of this software.<br>
      Permission is granted to anyone to use this software for any purpose,<br>
      including commercial applications, and to alter it and redistribute it<br>
      freely, subject to the following restrictions:<br>
      <br>
      1. The origin of this software must not be misrepresented; you must not<br>
      claim that you wrote the original software. If you use this software<br>
      in a product, an acknowledgment in the product documentation would be<br>
      appreciated but is not required.<br>
      2. Altered source versions must be plainly marked as such, and must not be<br>
      misrepresented as being the original software.<br>
      3. This notice may not be removed or altered from any source distribution.<br>
      <br>
      <span style="text-decoration: underline;"> Third–party license</span><br>
      <br>
      Copyright (c) 2007 – 2010 The Khronos Group Inc.<br>
      <br>
      Permission is hereby granted, free of charge, to any person obtaining a<br>
      copy of this software and/or associated documentation files (the<br>
      "Materials"), to deal in the Materials without restriction, including<br>
      without limitation the rights to use, copy, modify, merge, publish,<br>
      distribute, sublicense, and/or sell copies of the Materials, and to<br>
      permit persons to whom the Materials are furnished to do so, subject to<br>
      the following conditions:<br>
      <br>
      The above copyright notice and this permission notice shall be included<br>
      in all copies or substantial portions of the Materials.<br>
      <br>
      THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE MATERIALS OR THE
      USE OR OTHER DEALINGS IN THE MATERIALS. </big>
    <h2><a name="mozTocId336772" class="mozTocH2"></a><big>Chapter 4. System
        requirements</big></h2>
    <big> </big>
    <p><big>You can see minimum system requirement below.</big></p>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Operating system </big></td>
          <td><big>Windows XP or higher </big></td>
        </tr>
        <tr>
          <td><big>Minimum color depth </big></td>
          <td><big>16 bits </big></td>
        </tr>
        <tr>
          <td><big>Sound card </big></td>
          <td><big>Any sound card </big></td>
        </tr>
        <tr>
          <td colspan="1" rowspan="2"><big>Processor </big></td>
          <td><big>Intel Pentium 4 for 32–bit system </big></td>
        </tr>
        <tr>
          <td><big>Intel Core 2 Duo for 64–bit system </big></td>
        </tr>
      </tbody>
    </table>
    <big> </big>
    <h2><a name="mozTocId928115" class="mozTocH2"></a><big>Chapter 5. Trouble
        guide</big></h2>
    <big><br>
      You need <a href="https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads">Visual
C++ Redistributable Packages</a> if you game code compiled under Visual C++.
    </big>
    <h2><a name="mozTocId491993" class="mozTocH2"></a><big>Chapter 6. Compilers</big></h2>
    <big> This engine successfully tested with these compilers: </big> <br>
    <ul>
      <li><a href="https://jmeubank.github.io/tdm-gcc/"><big>TDM–GCC</big></a></li>
      <li><a href="http://mingw-w64.org"><big>MINGW–w64</big></a></li>
      <li><big>Visual C++ 2008<br>
        </big></li>
      <li><big>Visual C++ 2010</big></li>
      <li><big>Visual C++ 2012</big></li>
      <li><big>Visual C++ 2013</big></li>
      <li><big>Visual C++ 2015</big></li>
      <li><big>Visual C++ 2017</big></li>
      <li><big>Visual C++ 2019</big></li>
      <li><big>Visual C++ 2022</big></li>
      <li><big>C++ Builder XE4</big></li>
      <li><big>C++ Builder XE5</big></li>
      <li><big>C++ Builder XE6</big></li>
      <li><big>C++ Builder XE7</big></li>
      <li><big>C++ Builder XE8</big></li>
      <li><big>C++ Builder 10 Seattle</big></li>
      <li><big>C++ Builder 10.1 Berlin</big></li>
      <li><big>C++ Builder 10.2 Tokyo</big></li>
      <li><big>C++ Builder 10.3 Rio</big></li>
      <li><big>C++ Builder 10.4 Sydney</big></li>
      <li><big>C++ Builder 11 Alexandria</big></li>
    </ul>
    <h2><a name="mozTocId56069" class="mozTocH2"></a><big>Chapter 7. Platform
        specific notes</big></h2>
    <big><span style="text-decoration: underline;">DirectX</span><br>
      <br>
      You need to update <a href="https://www.microsoft.com/en-us/download/details.aspx?id=8109">DirectX
        End-User Runtime</a> before run your game.<br>
      <br>
      <span style="text-decoration: underline;">Windows XP support</span><br>
      <br>
      You need TDM–GCC or Visual C++ 2008 for <a href="https://en.wikipedia.org/wiki/Windows_XP">Windows
        XP</a> support.<span style="text-decoration: underline;"><br>
      </span></big><br>
    <big> </big><big><span style="text-decoration: underline;">Compiler
        optimization</span><br>
      <br>
      Disable all compiler optimization for correct working. See documentation
      of your favorite compiler for more information about compiler
      optimization.<br>
      <br>
      <span style="text-decoration: underline;"> Note for Visual C++ users</span><br
        style="text-decoration: underline;">
      <br>
      Disable pre–compiled headers before start compilation. Old Visual C++
      users can do it via project creation wizard.<br>
      Visual C++ 2017 or higher users must follow these steps:<br>
    </big>
    <ul>
      <li><big> Go to «Project properties – C/C++ – Precompiled Headers»</big></li>
      <li><big> Set «Precomiled Header» option to «Not Using Precompiled
          Headers»</big></li>
    </ul>
    <big> <span style="text-decoration: underline;"> Note for MINGW–w64 and
        TDM–GCC users</span><br>
      <br>
      Don't forget to link your program with these files: </big>
    <ul>
      <li><big>user32.lib</big></li>
      <li><big>kernel32.lib</big></li>
      <li><big>gdi32.lib</big></li>
      <li><big>opengl32.lib</big></li>
      <li><big>ole32.lib</big></li>
      <li><big>strmiids.lib</big></li>
      <li><big>xinput.lib</big></li>
    </ul>
    <big> See documentation of the compiler for more information about linking.
    </big>
    <h2><a name="mozTocId914689" class="mozTocH2"></a><big>Chapter 8. The engine
        name–space</big></h2>
    <big><span style="font-style: italic;">SWGF</span> is the main name–space.</big><big>
      All the engine classes declared in few nested namespaces.<br>
    </big>
    <h2><a name="mozTocId417277" class="mozTocH2"></a><big>Chapter 9. Custom
        date types</big></h2>
    <big>Almost all custom data types declared in <span style="font-style: italic;">SWGF</span>
      namespace.<br>
    </big>
    <h1><a name="mozTocId859712" class="mozTocH1"></a><big>Part 2. Base things</big></h1>
    <big> </big>
    <h2><a name="mozTocId312970" class="mozTocH2"></a><big>Chapter 1. Coordinate
        system</big></h2>
    <big><br>
      The engine uses standard coordinate system by default. Coordinates start
      at top–left corner. Look to this picture to understand it.<br>
      <br>
      <img style="width: 107px; height: 111px;" alt="" src="coordinate_system.png">
    </big>
    <h2><a name="mozTocId544184" class="mozTocH2"></a><big>Chapter 2. A game
        cycle</big></h2>
    <big><br>
      What is the main point in your game? A game cycle. You can see the
      structure of a typical game cycle below.<br>
      <br>
      <img style="width: 379px; height: 354px;" alt="" src="game_cycle.png"> </big>
    <h1><a name="mozTocId760374" class="mozTocH1"></a><big>Part 3. Graphics</big></h1>
    <h2><a name="mozTocId182571" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>All subsystems in this section declared in <i>Graphics</i>
      sub–namespace.</big><br>
    <big> </big>
    <h2><a name="mozTocId552078" class="mozTocH2"></a><big>Chapter 2. Base
        graphics subsystem</big></h2>
    <big> <span style="text-decoration: underline;"> Introduce to base graphics
        subsystem</span><br>
      <br>
      Base graphics subsystem do rendering game scene. This subsystem using <a
        href="http://opengl.org">OPENGL</a> for render. Most modern video–card
      support hardware accelerated OPENGL. Software emulated OPENGL will
      activate if </big><big>hardware acceleration not available.</big><br>
    <big> <br>
      <span style="text-decoration: underline;"> Render performance</span><br>
      <br>
      Always use latest video–card drivers. It can increase render performance.
      You can also try to change screen resolution if you have low render
      performance.<br>
      <br style="text-decoration: underline;">
      <span style="text-decoration: underline;"> Fps limitation</span><br>
      <br>
      Fps is an important thing. Many fps need for good animation, but it also
      needs high processor usage. Fps limit is 60 by default. It is optimal
      value.<br>
      <br>
      <span style="text-decoration: underline;"> Work with base graphics
        subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Screen</span> class provide access to
      the base graphic subsystem. Let's look at public methods.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;"> void Screen::clear_screen();</span> –
      Clear the screen. Fill it by black color.<br>
      <br>
      <span style="font-style: italic;"> void Screen::initialize();</span> –
      Initialize the base graphic subsystem with default screen resolution.<br>
      <br>
    </big><big style="font-style: italic;">void Screen::initialize(const
      unsigned int width,</big><big style="font-style: italic;">const unsigned
      int heigt</big><big><span style="font-style: italic;">);</span> –
      Initialize the base graphic subsystem with custom screen resolution.<br>
      <br>
    </big><big> <span style="font-style: italic;"> bool Screen::sync();</span>
      – Show current back–buffer content on screen. Return false if a game is
      terminated. This method uses fps limit and do wait between frames.<br>
      <br>
      <span style="font-style: italic;"> bool Screen::update();</span> – Show
      current back–buffer content on screen. Return false if a game is
      terminated. This method ignoring fps limit and need high processor usage.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">bool Screen::sync(const bool limit);</span>
      – Show current back–buffer content on screen. Return false if a game is
      terminated.<br>
      <br>
      <span style="font-style: italic;"> bool Screen::is_ready();</span> –
      Return true if the subsystem is already initialized.<br>
      <br>
      <span style="font-style: italic;"> bool Screen::is_accelerated() const;</span>
      – Return true if render is hardware accelerated.<br>
      <br>
      <span style="font-style: italic;"> bool Screen::is_software() const;</span>
      – Return true if software render is active.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Screen::get_fps() const;</span>
      – Return current fps value.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Screen::get_color()
        const;</span> – Return current color depth in bits per pixel.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Screen::get_width() const;</span>
      – Return screen width in pixels.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Screen::get_height()
        const;</span> – Return screen height in pixels.<br>
      <br>
      <span style="font-style: italic;">bool Screen::check_x(const unsigned int
        x) const;</span> – Return true if x-coordinate is valid.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">bool Screen::check_y(const unsigned int
        y) const;</span> – Return true if y-coordinate is valid.<br>
      <br>
      <span style="font-style: italic;"> Screen* Screen::get_handle();</span> –
      Return the handle to base graphics subsystem object. </big>
    <h2><a name="mozTocId289525" class="mozTocH2"></a><big>Chapter 3. Picture
        subsystem</big></h2>
    <big><span style="text-decoration: underline;"> An important subsystem</span><br>
      <br>
      Picture subsystem implement image storage.<br>
      <br>
    </big><big><span style="text-decoration: underline;"> Work with picture
        subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Picture</span> class provide simple
      access to picture subsystem. Don't use it directly. Let's look at public
      methods.<br>
      <br>
      <span style="font-style: italic;"> unsigned int *Picture::get_image();</span>
      – Return handle to image storage.<br>
      <br>
    </big><big><span style="font-style: italic;">void Picture::destroy_image();</span>
      – Destroy an image in the storage.<br>
      <br>
    </big><big> <span style="font-style: italic;"> bool
        Picture::is_storage_empty() const;</span> – Return true if storage is
      empty.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Picture::get_image_width()
        const;</span> – Return image width in pixels.<br>
      <br>
      <span style="font-style: italic;"> unsigned int
        Picture::get_image_height() const;</span> – Return image height in
      pixels.<br>
      <br>
    </big><big><span style="font-style: italic;">size_t
        Picture::get_image_lenght() const;</span> – Return image length in
      bytes.</big><br>
    <big> </big>
    <h2><a name="mozTocId501089" class="mozTocH2"></a><big>Chapter 4. Animation
        subsystem</big></h2>
    <big><span style="text-decoration: underline;"> An important subsystem</span><br>
      <br>
      Animation subsystem let you control animation frames.<br>
      <br style="text-decoration: underline;">
      <span style="text-decoration: underline;"> Frame indexing</span><br>
      <br>
      First frame index is 1.<br>
      <br>
      <span style="text-decoration: underline;"> Work with animation subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Animation</span> class provide simple
      access to animation subsystem. Don't use it directly. Let's look at public
      methods.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Animation::get_frames()
        const;</span> – Return amount of frames.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Animation::get_frame()
        const;</span> – Return current frame.<br>
      <br>
      <span style="font-style: italic;">bool Animation::is_last_frame() const;</span>
      – Return true if current frame is last frame.<br>
      <br>
      <span style="font-style: italic;">bool Animation::check_frame(const
        unsigned int target) const;</span> – Return true if target frame is
      valid.<br>
    </big>
    <h2><a name="mozTocId904725" class="mozTocH2"></a><big>Chapter 5. Image kind</big></h2>
    <big></big>
    <p><big> Image kind look as predefined constants. You can see it below.</big></p>
    <br>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Image kind<br>
            </big></td>
          <td><big>Description </big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_ANIMATED </big></td>
          <td><big>Horizontal scrolling background or horizontal strip </big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_ANIMATED </big></td>
          <td><big>Vertical scrolling background or vertical strip<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <br>
    <h2><a name="mozTocId738557" class="mozTocH2"></a><big>Chapter 6. Background</big></h2>
    <big><span style="text-decoration: underline;"> Level decoration</span><br>
      <br>
      Background is a big image. It is like decoration in theater stage. Any
      game has a background. The background will stretch to screen resolution
      before rendering the game scene. Background transparency is disabled.<br>
      <br>
      There are two background kinds: horizontal orientated scrolling background
      and vertical orientated scrolling background. It is a big image with few
      frames. Horizontal orientated scrolling background look like horizontal
      orientated photo ribbon. Vertical orientated scrolling background look
      like vertical orientated photo ribbon.<br>
    </big><big><br>
      <span style="text-decoration: underline;"> Work with background</span><br>
      <br>
      Just use <span style="font-style: italic;">Background</span> class to
      work with background. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Background* Background::get_handle();</span>
      – Return the handle to background object.<br>
    </big><big><br style="font-style: italic;">
      <span style="font-style: italic;"> void Background::prepare(const Screen
        *screen);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;"> void Background::prepare(Screen
        &amp;screen);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;"> void Background::prepare(const unsigned
        int width,const unsigned int heigt);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;">void Background::disable_mirror();</span>
      – Disable background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Background::horizontal_mirror();</span>
      – Set horizontal background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Background::vertical_mirror();</span>
      – Set vertical background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Background::complex_mirror();</span>
      – Set both horizontal and vertical background mirroring mode.<br>
      <br>
      <span style="font-style: italic;"> void Background::set_target(const
        unsigned int target);</span> – Set target frame in scrollable
      background.<br>
      <br>
      <span style="font-style: italic;"> void Background::step();</span> –
      Increase number of target frame. Set it to 1 if number of target frame
      more than frame amount.<br>
      <br>
      <span style="font-style: italic;"> void Background::set_setting(const
        SWGF::IMAGE_KIND kind,const unsigned int frames);</span> – Set setting.<br>
      <br>
      <span style="font-style: italic;"> void Background::load(Image
        *background,const SWGF::IMAGE_KIND kind,const unsigned int frames);</span>
      – Load a background </big><big>from the buffer</big><big>.<br>
      <br>
      <span style="font-style: italic;"> void Background::load(Image
        &amp;background,const SWGF::IMAGE_KIND kind,const unsigned int frames);</span>
      – Load a background </big><big>from the buffer</big><big>.<br>
      <span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;">void Background::load(const char
        *name,const SWGF::IMAGE_KIND kind,const unsigned int frames);</span> –
      Load a background </big><big>from target file</big><big>.<br>
      <br>
      <span style="font-style: italic;">void Background::load(</span></big><big
      style="font-style: italic;">const char *name</big><big><span style="font-style: italic;">);</span>
      – Load normal background from target file.<br>
      <br>
      <span style="font-style: italic;"> void Background::draw();</span> – Draw
      a background.<br>
      <br>
      <span style="font-style: italic;">void Background::draw(const unsigned int
        target);</span> – Draw target frame.<br>
      <br>
      <span style="font-style: italic;"> void Background::destroy_image();</span>
      – Destroy a background image.<br>
      <br>
      <span style="font-style: italic;"> void Background::destroy();</span> –
      Destroy a background image and destroy a background texture.<br>
      <br>
      <span style="font-style: italic;">bool Background::is_last_frame() const;</span>
      – Return true if current frame.<br>
      <br>
      <span style="font-style: italic;">bool Background::check_frame(const
        unsigned int target) const;</span> – Return true if target frame is
      valid.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Background::get_frame()
        const;</span> – Return current frame.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Background::get_frames()
        const;</span> – Return frame amount.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Background::get_width()
        const;</span> – Return the width of the background.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Background::get_height()
        const;</span> – Return the height of the background.<br>
      <br>
      <span style="font-style: italic;"> SWGF::IMAGE_KIND Background::get_kind()
        const;</span> – Get background type.<br>
      <br>
      <span style="text-decoration: underline;"> Background texture</span><br>
      <br>
      Background don't draw if background texture is don't exist. Background
      texture will automatically create after call <i>load</i> method.<br>
      <br>
      <span style="text-decoration: underline;"> Important notice</span><br>
      <br>
      Always call <span style="font-style: italic;">prepare</span> method after
      load background.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId515277"></a><big>Chapter 7. Static
        background</big></h2>
    <big><span style="text-decoration: underline;">A few words about static
        background</span><br>
      <br>
      The static background is simple kind of backgrounds. It contain one frame
      only.<br>
    </big><big><br>
      <span style="text-decoration: underline;"> Work with background</span><br>
      <br>
      Just use <span style="font-style: italic;">Scene</span> class to work
      with static background. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Scene* Scene::get_handle();</span> –
      Return the handle to background object.<br>
    </big><big><br style="font-style: italic;">
      <span style="font-style: italic;"> void Scene::prepare(const Screen
        *screen);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;"> void Scene::prepare(Screen
        &amp;screen);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;"> void Scene::prepare(const unsigned int
        width,const unsigned int heigt);</span> – Prepare for drawing.<br>
      <br>
      <span style="font-style: italic;">void Scene::disable_mirror();</span> –
      Disable background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Scene::horizontal_mirror();</span>
      – Set horizontal background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Scene::vertical_mirror();</span> –
      Set vertical background mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Scene::complex_mirror();</span> –
      Set both horizontal and vertical background mirroring mode.<br>
      <span style="font-style: italic;"></span><span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;"> void Scene::load(Image *background);</span>
      – Load a background from the buffer.<br>
      <br>
      <span style="font-style: italic;"> void Scene::load(Image
        &amp;background);</span> – Load a background </big><big>from the buffer</big><big>.<br>
      <br>
    </big><big><span style="font-style: italic;">void Scene::load(</span></big><big

      style="font-style: italic;">const char *name</big><big><span style="font-style: italic;">);</span>
      – Load a background from target file.</big><br>
    <big><br>
      <span style="font-style: italic;"> void Scene::draw();</span> – Draw a
      background.<br>
      <span style="font-style: italic;"></span><br>
      <span style="font-style: italic;"> void Scene::destroy_image();</span> –
      Destroy a background image.<br>
      <br>
      <span style="font-style: italic;"> void Scene::destroy();</span> – Destroy
      a background image and destroy a background texture.<br>
      <span style="font-style: italic;"></span><br>
      <span style="font-style: italic;"> unsigned int Scene::get_width() const;</span>
      – Return the width of the background.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Scene::get_height() const;</span>
      – Return the height of the background.<br>
      <span style="font-style: italic;"></span><br>
      <span style="text-decoration: underline;"> Background texture</span><br>
      <br>
      Background don't draw if background texture is don't exist. Background
      texture will automatically create after call <span style="font-style: italic;">load</span>
      method.<br>
      <br>
      <span style="text-decoration: underline;"> Important notice</span><br>
      <br>
      Always call <span style="font-style: italic;">prepare</span> method after
      load background.</big><br>
    <h2><a name="mozTocId309905" class="mozTocH2"></a><big>Chapter 8. Base
        sprite subsystem</big></h2>
    <big> </big><big><span style="text-decoration: underline;">Small important
        thing</span><br>
      <br>
      A sprite is a transparent image. It is useful for many things: enemies,
      bonuses, etc.<br>
    </big><big><br>
      <span style="text-decoration: underline;"> Work with base sprite subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Billboard</span> class provide simple
      access to base sprite subsystem. Don't use it directly. Let's look at
      public methods.<br>
    </big><big><br>
    </big><big><span style="font-style: italic;"> void
        Billboard::set_transparent(const bool enabled);</span> – Enable or
      disable the transparent mode.<br>
      <br>
      <span style="font-style: italic;"> bool Billboard::get_transparent()
        const;</span> – Return true if transparent mode is enable.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">void Billboard::set_start(const unsigned
        int x, const unsigned int y);</span> – Set start position of the sprite.<br>
      <br>
    </big><big><span style="font-style: italic;">void
        Billboard::set_position(const unsigned int x, const unsigned int y);</span>
      – Set sprite position.<br>
      <br>
      <span style="font-style: italic;"> void Billboard::set_size(const unsigned
        int width, const unsigned int height);</span> – Change the sprite size.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Billboard::set_x(const
        unsigned int x);</span> – Set x–coordinate of the sprite position.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Billboard::set_y(const
        unsigned int y);</span> – Set y–coordinate of the sprite position.<br>
      <br>
    </big><big> <span style="font-style: italic;"> void
        Billboard::set_width(const unsigned int width);</span> – Change the
      sprite width.<br>
      <br>
      <span style="font-style: italic;"> void Billboard::set_height(const
        unsigned int height);</span> – Change the sprite height.<br>
      <br>
    </big> <big><i>unsigned int Billboard::increase_x();</i> – Increase
      x–coordinate and return increased x–position.<br>
      <br>
    </big> <big><i>unsigned int Billboard::decrease_x();</i> – Decrease
      x–coordinate and return decreased x–position.<br>
      <br>
    </big> <big><i>unsigned int Billboard::increase_y();</i> – Increase
      y–coordinate and return increased y–position.<br>
      <br>
    </big> <big><i>unsigned int Billboard::decrease_y();</i> – Decrease
      y–coordinate and return increased y–position.<br>
      <br>
    </big> <big><i>unsigned int Billboard::increase_x(const unsigned int
        increment);</i> – Increase x–coordinate with user value and return
      increased x–position.<br>
      <br>
    </big> <big><i>unsigned int Billboard::decrease_x(const unsigned int
        decrement);</i> – Decrease x–coordinate with user value and return
      decreased x–position.<br>
      <br>
    </big> <big><i>unsigned int Billboard::increase_y(const unsigned int
        increment);</i> – Increase y–coordinate with user value and return
      increased y–position.<br>
      <br>
    </big> <big><i>unsigned int Billboard::decrease_y(const unsigned int
        decrement);</i> – Decrease y–coordinate with user value and return
      decreased y–position.<br>
      <br>
      <span style="font-style: italic;">unsigned int Billboard::get_start_x()
        const;</span> – Return x–coordinate of start position.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Billboard::get_start_y()
        const;</span> – Return y–coordinate of start position.<br>
      <br>
    </big><big> <span style="font-style: italic;"> unsigned int
        Billboard::get_x() const;</span> – Return x–coordinate of the sprite
      position.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Billboard::get_y() const;</span>
      – Return y–coordinate of the sprite position.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Billboard::get_width()
        const;</span> – Return the width of the sprite.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Billboard::get_height()
        const;</span> – Return the height of the sprite.<br>
      <br>
    </big><big><span style="font-style: italic;">SWGF::BOX Billboard::get_box()
        const;</span> – Return collision related information.<br>
      <br>
      <span style="font-style: italic;">void Billboard::disable_mirror();</span>
      – Disable sprite mirroring mode.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">void Billboard::horizontal_mirror();</span>
      – Set horizontal sprite mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Billboard::vertical_mirror();</span>
      – Set vertical sprite mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Billboard::complex_mirror();</span>
      – Set both horizontal and vertical sprite mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Billboard::go_start();</span> – Set
      sprite position to start position.<br>
      <br>
      <span style="font-style: italic;">void Billboard::go_start_x();</span> –
      Set x–coordinate of sprite position to x–coordinate of start position.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">void Billboard::go_start_y();</span> –
      Set y–coordinate of sprite position to y–coordinate of start position.<br>
      <br>
    </big><big> </big><big><span style="font-style: italic;">void
        Billboard::draw();</span> – Draw a sprite.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Billboard::draw(const
        unsigned int x, const unsigned int y);</span> – Set sprite position and
      draw it.<br>
      <br>
    </big> <big><i>void Billboard::draw(const bool transparency);</i> – Set
      transparent mode and draw a sprite.<br>
      <br>
    </big> <big><i>void Billboard::draw(const bool transparency,const unsigned
        int x, const unsigned int y);</i> – Set transparent mode and draw a
      sprite at target position.</big><br>
    <big> </big>
    <h2><a name="mozTocId662651" class="mozTocH2"></a><big> Chapter 9. Ordinary
        sprites</big></h2>
    <big><span style="text-decoration: underline;"> Sprite types</span><br>
      <br>
      There are two kinds of ordinary sprites: </big><big>horizontal strip and
      vertical strip</big><big>. It is a small image with few frames. Do you
      remember an analog camera? <br>
      Strip look like photo ribbon. Horizontal strip look like the horizontal
      orientated photo ribbon.<br>
      Vertical strip look like the vertical orientated photo ribbon.<br>
    </big><big><br>
    </big><big><span style="text-decoration: underline;">Frame indexing</span><br>
      <br>
      First frame index is 1.</big><br>
    <big><br style="text-decoration: underline;">
      <span style="text-decoration: underline;"> Work with sprites</span><br>
      <br>
      Just use <span style="font-style: italic;">Sprite</span> class to work
      with a sprite. It is derived from threeclasses: </big><big><span style="font-style: italic;">Billboard</span>,
      <span style="font-style: italic;">Animation</span> and <span style="font-style: italic;">Picture</span></big><big>.
      Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::set_setting(const
        SWGF::IMAGE_KIND kind,const unsigned int frames);</span> – Set sprite
      settings.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::load(Image *buffer,const
        SWGF::IMAGE_KIND kind,const unsigned int frames);</span> – Load a sprite
      from the buffer.<br>
      <span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;"> void Sprite::load(Image
        &amp;buffer,const SWGF::IMAGE_KIND kind,const unsigned int frames);</span>
      – Load a sprite </big><big>from the buffer</big><big>.<br>
      <span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;">void Sprite::load(const char *name,const
        SWGF::IMAGE_KIND kind,const unsigned int frames);</span> – Load a sprite
    </big><big>from target file</big><big>.<br>
      <span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;"> void Sprite::set_target(const unsigned
        int target);</span> – Set target frame.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::step();</span> – Increase
      number of target. Set it to 1 if number of target frame more than frame
      amount.<br>
      <br>
      <span style="font-style: italic;"> SWGF::IMAGE_KIND Sprite::get_kind()
        const;</span> – Get sprite type.<br>
      <br>
    </big><big> <span style="font-style: italic;"> Sprite*
        Sprite::get_handle();</span> – Return the handle to sprite object.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::clone(Sprite *target);</span>
      – Create copy of the sprite if the image storage of target sprite is not
      empty.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::clone(Sprite &amp;target);</span>
      – Create copy of the sprite if the image storage of target sprite is not
      empty.<br>
      <br>
      <span style="font-style: italic;"> void Sprite::destroy(); </span>–
      Destroy a sprite image and destroy a sprite texture.</big><big><br>
    </big> <big><br>
      <span style="text-decoration: underline;"> Sprite texture</span><br>
      <br>
      Sprite will don't draw if sprite texture is don't exist. Sprite texture
      will automatically create when load or clone sprite.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId477705"></a><big>Chapter 10. Static
        sprites</big></h2>
    <big><span style="text-decoration: underline;">A few words about static
        sprite</span><br>
      <br>
      The static sprite is simple kind of sprites. It contain one frame only.<br>
    </big><big><span style="text-decoration: underline;"></span></big><big><br style="text-decoration: underline;">
      <span style="text-decoration: underline;"> Work with static sprites</span><br>
      <br>
      Just use <span style="font-style: italic;">Cartoon</span> class to work
      with a static sprite. It is derived from two classes: </big><big><span style="font-style: italic;">Billboard</span>
      and <span style="font-style: italic;">Picture</span></big><big>. Let's
      look at public methods.<br>
      <span style="font-style: italic;"></span><br>
      <span style="font-style: italic;"> void Cartoon::load(Image *buffer);</span>
      – Load a sprite </big><big>from the buffer</big><big>.<br>
      <span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;"> void Cartoon::load(Image &amp;buffer);</span>
      – Load a sprite </big><big>from the buffer</big><big>.<br>
      <span style="font-style: italic;"></span></big><big><br>
      <span style="font-style: italic;">void Cartoon::load(</span></big><big style="font-style: italic;">const
      char *name</big><big><span style="font-style: italic;">);</span> – Load a
      sprite from target file.<br>
      <span style="font-style: italic;"></span><br>
    </big><big> <span style="font-style: italic;"> Cartoon*
        Cartoon::get_handle();</span> – Return the handle to sprite object.<br>
      <br>
      <span style="font-style: italic;"> void Cartoon::clone(Cartoon *target);</span>
      – Create copy of the sprite if the image storage of target sprite is not
      empty.<br>
      <br>
      <span style="font-style: italic;"> void Cartoon::clone(Cartoon
        &amp;target);</span> – Create copy of the sprite if the image storage of
      target sprite is not empty.<br>
      <br>
      <span style="font-style: italic;"> void Cartoon::destroy(); </span>–
      Destroy a sprite image and destroy a sprite texture.</big><big><br>
    </big> <big><br>
      <span style="text-decoration: underline;"> Sprite texture</span><br>
      <br>
      Sprite will don't draw if sprite texture is don't exist. Sprite texture
      will automatically create when load or clone sprite.</big><br>
    <big> </big>
    <h2><a name="mozTocId146800" class="mozTocH2"></a><big>Chapter 11. Sprite
        sheet</big></h2>
    <big><span style="text-decoration: underline;"> Some words about sprite
        sheet</span><br>
      <br>
      Sprite sheet is a special kind of animated sprites. Each frame has fixed
      size. A sprite sheet is a matrix of frames. Look to this picture to
      understand it.<br>
      <br>
      <img src="sheet.png"><br>
      <br>
      <span style="text-decoration: underline;"> Row and column</span><br>
      <br>
      First row index is 1. First column index is 1.<br>
    </big><big><br>
    </big><big><span style="text-decoration: underline;"> Work with sprite sheet
        subsystem</span><br>
      <br>
      <span style="font-style: italic;"> Sheet</span> class provide access to
      the sprite sheet subsystem. </big><big>It is derived from&nbsp; three </big><big>classes:
      <span style="font-style: italic;">Billboard</span>, <span style="font-style: italic;">Picture</span>
      and <span style="font-style: italic;">Animation</span>. Let's look at
      public methods.<br>
      <br>
      <span style="font-style: italic;">bool Sheet::check_row(const unsigned int
        target) const;</span> – Return true if target row is valid.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">bool Sheet::check_column(const unsigned
        int target) const;</span> – Return true if target column is valid.<br>
      <br>
    </big><big style="font-style: italic;"> unsigned int Sheet::get_row(</big><big

      style="font-style: italic;">const unsigned int target</big><big><span style="font-style: italic;">)
        const;</span> – Return row of target frame.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Sheet::get_column(</span></big><big

      style="font-style: italic;">const unsigned int target</big><big><span style="font-style: italic;">)
        const;</span> – Return</big><big> column</big><big> </big><big>of
      target frame</big><big>.<br>
      <br>
    </big> <big><span style="font-style: italic;">unsigned int
        Sheet::calculate(const unsigned int row,const unsigned int column)
        const;</span> – Calculate the frame by row and column.<br>
      <br>
    </big> <big><span style="font-style: italic;"> unsigned int
        Sheet::get_rows() const;</span> – Return row amount.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Sheet::get_columns()
        const;</span> – Return</big><big> column</big><big> amount.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Sheet::destroy();</span>
      – Destroy a sprite sheet image and destroy a sprite sheet texture.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Sheet::select(const
        unsigned int row,const unsigned int column);</span> – Select the sprite
      by row and column.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Sheet::select(const
        unsigned int target);</span> – Select the sprite by frame number.<br>
      <br>
    </big><big><span style="font-style: italic;">void Sheet::step();</span> –
      Increase number of target frame. Set it to 1 if number of target frame
      more than frame amount.<br>
      <br>
    </big> <big><span style="font-style: italic;"> void Sheet::load(Image
        *sheet,const unsigned int row_amount,const unsigned int column_amount);</span>
      – Load a sprite sheet from the buffer.<br>
      <br>
      <span style="font-style: italic;"> void Sheet::load(Image &amp;sheet,const
        unsigned int row_amount,const unsigned int column_amount);</span> – Load
      a sprite sheet from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Sheet::load(const char *name,const
        unsigned int row_amount,const unsigned int column_amount);</span> – Load
      a sprite sheet from target file.<br>
      <br>
      <span style="font-style: italic;">Sheet* Sheet::get_handle();</span> –
      Return the handle to sprite sheet.<br>
      <br>
      <span style="font-style: italic;">void Sheet::clone(Sheet *target);</span>
      – Create copy of the sprite sheet if the image storage of target sprite
      sheet is not empty.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">void Sheet::clone(Sheet &amp;target);</span>
      – Create copy of the sprite sheet if the image storage of target sprite
      sheet is not empty.<br>
      <br>
      <span style="text-decoration: underline;"> Sprite sheet texture</span><br>
      <br>
      Sprite will don't draw if sprite sheet texture is don't exist. A sprite
      sheet texture will automatically create after call <span style="font-style: italic;">load_sheet</span>
      method.<br>
    </big>
    <h2><a name="mozTocId752257" class="mozTocH2"></a><big>Chapter 12. Text</big></h2>
    <big><span style="text-decoration: underline;"> How to draw a text?</span><br>
      <br>
      Just use text subsystem to draw a text. This subsystem need a font for
      text drawing. You must load a font before start draw the text. The font is
      just a sprite sheet with 16 rows and 16 columns.<br>
      <br>
      <span style="text-decoration: underline;"> Valid characters</span><br>
      <br>
      Only 8–bit </big><big>characters</big><big> supported.<br>
      <br>
    </big><big style="text-decoration: underline;">Text orientation</big><br>
    <br>
    <big>Text orientation look as predefined constants. You can see it below.<br>
      <br>
    </big> <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Text orientation<br>
            </big></td>
          <td><big>Description </big></td>
        </tr>
        <tr>
          <td><big>HORIZONTAL_TEXT </big></td>
          <td><big>Horizontal orientated text<br>
            </big></td>
        </tr>
        <tr>
          <td><big>VERTICAL_TEXT </big></td>
          <td><big>Vertical orientated text</big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <span style="text-decoration: underline;"> Work with text</span><br>
      <br>
      <span style="font-style: italic;"> Text</span> class provide a simple
      interface to text subsystem. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Text* Text::get_handle();</span> –
      Return the handle to text drawing subsystem.<br>
      <br>
      <span style="font-style: italic;"> SWGF::TEXT_KIND Text::get_orientation()
        const;</span> – Get current text orientation.<br>
      <br>
      <span style="font-style: italic;"> void Text::set_orientation(const
        SWGF::TEXT_KIND target);</span> – Set current text orientation.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Text::get_font_width()
        const;</span> – Get current font width in pixels.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Text::get_font_height()
        const;</span> – Get current font height in pixels.<br>
      <br>
      <span style="font-style: italic;"> void Text::set_position(const unsigned
        int x,const unsigned int y);</span> – Set output position.<br>
      <br>
      <span style="font-style: italic;"> void Text::set_size(const unsigned int
        width,const unsigned int height);</span> – Change the font size.<br>
      <br>
      <span style="font-style: italic;">void Text::set_width(const unsigned int
        width);</span> – Set the font width.<br>
      <br>
      <span style="font-style: italic;">void Text::set_height(const unsigned int
        height);</span> – Set the font height.<br>
      <br>
      <span style="font-style: italic;">void Text::set_setting(const unsigned
        int width,const unsigned int height,const SWGF::TEXT_KIND kind);</span>
      – Set text output settings.<br>
      <br>
      <span style="font-style: italic;"> void Text::load_font(Image *font);</span>
      – Load a font from the buffer.<br>
      <br>
      <span style="font-style: italic;"> void Text::load_font(Image &amp;font);</span>
      – Load a font from the buffer.<br>
      <br>
      <span style="font-style: italic;">void Text::load_font(const char *name);</span>
      – Load a font from target file.<br>
      <br>
      <span style="font-style: italic;"> void Text::print(const char target);</span>
      – Draw single character at current position.<br>
      <br>
      <span style="font-style: italic;"> void Text::print(const char *target);</span>
      – Draw text at current position.<br>
      <br>
      <span style="font-style: italic;"> void Text::print(const unsigned int
        x,const unsigned int y,const char target);</span> – Draw single
      character at specific position.<br>
      <br>
      <span style="font-style: italic;"> void Text::print(const unsigned int
        x,const unsigned int y,const char *target);</span> – Draw text at
      specific position.<br>
      <br>
      <span style="font-style: italic;">void Text::disable_mirror();</span> –
      Disable text mirroring mode.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">void Text::horizontal_mirror();</span> –
      Set horizontal text mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Text::vertical_mirror();</span> –
      Set vertical text mirroring mode.<br>
      <br>
      <span style="font-style: italic;">void Text::complex_mirror();</span> –
      Set both horizontal and vertical text mirroring mode.<br>
      <br>
      <span style="font-style: italic;"> void Text::destroy_image();</span> –
      Destroy a font image.<br>
      <br>
      <span style="font-style: italic;"> void Text::destroy_font();</span> –
      Destroy a font image and destroy a font texture.<br>
    </big><big> </big>
    <h2><a name="mozTocId67980" class="mozTocH2"></a><big>Chapter 13. Loading
        images</big></h2>
    <big><span style="text-decoration: underline;"> Load an image from files</span><br>
      <br>
      Use image loader to load an image from a file. <span style="font-style: italic;">Image</span>
      class provide simple access to image loader. It is a simple class with few
      methods.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;"> </span></big><big><span style="font-style: italic;">unsigned
        char *</span></big><big><span style="font-style: italic;">Image::load_tga(const
        char *name);</span> – Load a Truevision TGA image and return handle to
      image buffer.<br>
      <br>
      <span style="font-style: italic;">unsigned char *Image::get_data();</span>&nbsp;
      – Return handle to image buffer.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Image::get_width() const;</span>
      – Return width of current image.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Image::get_height() const;</span>
      – Return height of current image.<br>
      <br>
      <span style="font-style: italic;"> size_t Image::get_length() const;</span>
      – Return length of image buffer in bytes.<br>
      <br>
      <span style="font-style: italic;"> Image* Image::get_handle();</span> –
      Return the handle to image loader.<br>
      <br>
      <span style="font-style: italic;"> void Image::destroy_image();</span> –
      Destroy the current image and free image buffer.<br>
      <br>
      <span style="text-decoration: underline;"> Important remark</span><br>
      <br>
      A new image will replace current image if current image already exist.
      Incorrect images will ignore and don't load.<br>
      Source image will convert to <a href="https://en.wikipedia.org/wiki/RGBA">RGBA</a>
      format. Pixels equal to top-left pixel will mark as transparent.<br>
      <br>
      <span style="text-decoration: underline;"> Supported format</span><br>
    </big>
    <p><big> All loading images must have correct specification. You can load an
        image from 24 bit </big><big><a href="https://en.wikipedia.org/wiki/Truevision_TGA">Truevision
          TGA</a> pictures. </big></p>
    <big><span style="text-decoration: underline;"> Recommend software</span><br>
      <br>
      You can use a wide range of graphics software to convert your images to
      the correct format. I recommend use <a href="https://www.gimp.org">GIMP</a>
      for doing it. It is a powerful image editor.<br>
    </big>
    <h1><a class="mozTocH1" name="mozTocId99230"></a><a id="mozTocId532116" class="mozTocH1"></a><big>Part
        4. Transformation</big></h1>
    <big></big>
    <h2><a class="mozTocH2" name="mozTocId248613"></a><a id="mozTocId178104" class="mozTocH2"></a><big>Chapter
        1. The sub–namespace</big></h2>
    <big> All subsystems in this section declared in <span style="font-style: italic;">Transformation</span>
      sub–namespace.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId462005"></a><big>Chapter 2. Cartesian
        coordinates and screen coordinates</big></h2>
    <big><span style="text-decoration: underline;"> Cartesian coordinates</span><br>
      <br>
      Cartesian coordinates start at center of the screen. Look to this picture
      to understand it.<br>
      <br>
      <img style="width: 107px; height: 111px;" alt="" src="cartesian_system.png"><br>
      <br>
      <span style="text-decoration: underline;"> Cartesian coordinates to screen
        coordinates conversion and screen coordinates to cartsian coordinates
        conversion</span><br>
      <br>
      You can convert cartesian coordinates to screen coordinates. You can also
      convert screen coordinates to cartesian coordinates.<br>
      Just use <span style="font-style: italic;">Coordinates</span> class for
      doing it. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Coordinates* Coordinates::get_handle();</span>
      – Return the handle to coordinates conversion subsystem.<br>
      <br>
      <span style="font-style: italic;"> void Coordinates::initialize(const int
        viewport_width,const int viewport_height);</span> – Initialize the
      subsystem.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">int Coordinates::get_viewport_width()
        const;</span> – Return view-port width in pixels.<br>
      <br>
      <span style="font-style: italic;">int Coordinates::get_viewport_height()
        const;</span> – Return view-port height in pixels.<br>
      <br>
      <span style="font-style: italic;">int
        Coordinates::get_lowest_cartesian_x() const;</span> – Return lowest
      allowable cartesian x-coordinate.<br>
      <br>
      <span style="font-style: italic;">int
        Coordinates::get_highest_cartesian_x() const;</span> – Return highest
      allowable cartesian x-coordinate.<br>
      <br>
      <span style="font-style: italic;">int
        Coordinates::get_lowest_cartesian_y() const;</span> – Return lowest
      allowable cartesian y-coordinate.<br>
      <br>
      <span style="font-style: italic;">int
        Coordinates::get_highest_cartesian_y() const;</span> – Return highest
      allowable cartesian y-coordinate.<br>
      <br>
      <span style="font-style: italic;">bool
        Coordinates::check_cartesian_x(const int x) const;</span> – Return true
      if the cartesian x-coordinate is valid.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">bool
        Coordinates::check_cartesian_y(const int y) const;</span> – Return true
      if the cartesian y-coordinate is valid.<br>
      <br>
      <span style="font-style: italic;"> int Coordinates::get_screen_x(const int
        x) const;</span> – Convert cartesian x-coordinate to screen
      x-coordinate.<br>
      <br>
      <span style="font-style: italic;"> int Coordinates::get_screen_y(const int
        y) const;</span> – Convert cartesian y-coordinate to screen
      y-coordinate.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;"> int Coordinates::get_cartesian_x(const
        int x) const;</span> – Convert screen x-coordinate to cartesian
      x-coordinate.<br>
      <br>
      <span style="font-style: italic;"> int Coordinates::get_cartesian_y(const
        int y) const;</span> – Convert screen y-coordinate to cartesian
      y-coordinate.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId251950"></a><big>Chapter 3. Cartesian
        coordinates and isometric coordinates</big></h2>
    <big><span style="text-decoration: underline;">A few words about isometric</span><br>
      <br>
      <a href="https://en.wikipedia.org/wiki/Isometric_projection">Isometric</a>
      is very popular way for pseudo-3D games. Many old-school games are
      isometric games.<br>
      <br>
    </big><big><span style="text-decoration: underline;">Cartesian coordinates
        to isometric coordinates conversion and isometric coordinates to
        cartsian coordinates conversion</span><br>
      <br>
      You can convert cartesian coordinates to isometric coordinates. You can
      also convert isometric coordinates to cartesian coordinates.<br>
      Just use <span style="font-style: italic;">Isometric</span> class for
      doing it. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Isometric* Isometric::get_handle();</span>
      – Return the handle to isometric subsystem.<br>
      <br>
    </big><big><span style="font-style: italic;">void
        Isometric::set_target(const int x,const int y);</span> – Set target
      point.</big><big><span style="font-style: italic;"></span></big><big><br>
      <br>
      <span style="font-style: italic;">int Isometric::get_isometric_x() const;</span>
      – Convert x-coordinate of target point from cartesian system to isometric
      system.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">int Isometric::get_isometric_y() const;</span>
      – Convert y-coordinate of target point from cartesian system to isometric
      system.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">int Isometric::get_cartesian_x() const;</span>
      – Convert x-coordinate of target point from isometric system to cartesian
      system.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">int Isometric::get_cartesian_y() const;</span>
      – Convert y-coordinate of target point from isometric system to cartesian
      system.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">int Isometric::get_isometric_x(const int
        x,const int y);</span> – Set target point and convert x-coordinate from
      cartesian system to isometric system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_isometric_y(const int
        x,const int y);</span> – Set target point and convert y-coordinatefrom
      cartesian system to isometric system.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">int Isometric::get_cartesian_x(const int
        x,const int y);</span> – Set target point and convert x-coordinatefrom
      isometric system to cartesian system.<br>
      <br>
      <span style="font-style: italic;">int Isometric::get_cartesian_y(const int
        x,const int y);</span> – Set target point and convert y-coordinate from
      isometric system to cartesian system.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId143616"></a><big>Chapter 4. Isometric
        level<br>
      </big></h2>
    <big><span style="text-decoration: underline;"></span> Isometric level
      subsystem intend for help you to create an isometric levels. Just use <span
        style="font-style: italic;">World</span> class for doing it. Let's look
      at public methods.<br>
      <br>
      <span style="font-style: italic;">World* World::get_handle();</span> –
      Return the handle to isometric level subsystem.<br>
      <br>
      <span style="font-style: italic;">void World::initialize(const int
        tile_width,const int tile_height,const int screen_width,const int
        screen_height);</span> – Initialize the subsystem.<br>
      <br>
      <span style="font-style: italic;">int World::get_target_x(const int row,</span></big><big
      style="font-style: italic;">const int column</big><big><span style="font-style: italic;">)
        const;</span> – Get target cartesian x-coordinate from the row and
      column.<br>
      <br>
      <span style="font-style: italic;">int World::get_target_y(const int row</span></big><big
      style="font-style: italic;">,</big><big style="font-style: italic;">const
      int column</big><big><span style="font-style: italic;">) const;</span> –
      Get target cartesian y-coordinate </big><big>from the row and column.<br>
      <br>
    </big><big><span style="font-style: italic;">int World::get_row(const int x,</span></big><big
      style="font-style: italic;">const int y</big><big><span style="font-style: italic;">)
        const;</span> – Get the row from target point.<br>
      <br>
      <span style="font-style: italic;">int World::get_column(const int y</span></big><big
      style="font-style: italic;">,</big><big style="font-style: italic;">const
      int y</big><big><span style="font-style: italic;">) const;</span> – Get
      the column</big><big> from target point.<br>
      <br>
      <span style="font-style: italic;">int World::get_row_amount() const;</span>
      – Get amount of maximum visible rows.<br>
      <br>
      <span style="font-style: italic;">int World::get_column_amount() const;</span>
      – Get amount of maximum visible columns.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">int World::get_tile_amount() const;</span>
      – Get amount of maximum visible isometric tiles.<br>
    </big> <big> </big>
    <h1><a name="mozTocId64443" class="mozTocH1"></a><big>Part 5. Common things</big></h1>
    <h2><a name="mozTocId597525" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>Almost all subsystems in this section declared in <span style="font-style: italic;">Common</span>
      sub–namespace.<br>
    </big> <big></big> <big> </big> <big> </big>
    <h2><a name="mozTocId853711" class="mozTocH2"></a><big>Chapter 2. Abnormal
        program termination</big></h2>
    <big> You can use <span style="font-style: italic;">Halt</span> function to
      terminate a program. This function declared in <span style="font-style: italic;">SWGF</span>
      name–space.<br>
      <br>
      <span style="font-style: italic;"> void SWGF::Halt(const char *message);</span>
      – Terminate the program. Write error message to log file if logging
      enabled. </big><big> </big>
    <h2><a name="mozTocId656377" class="mozTocH2"></a><big>Chapter 3. Timer</big></h2>
    <big> Timer is a very useful thing. Just use <span style="font-style: italic;">Timer</span>
      class to work with the timer. Let's look at public methods.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">Timer* Timer::get_handle();</span> –
      Return the handle to the timer.<br>
      <br>
      <span style="font-style: italic;"> void Timer::set_timer(const double
        seconds); </span>– Set timer interval and initialize start point.<br>
      <br>
      <span style="font-style: italic;">double Timer::get_interval() const;</span>
      – Return current timer interval.<br>
      <br>
      <span style="font-style: italic;"> bool Timer::check_timer();</span> –
      Return true and reinitialize start point if interval between stop and
      start points large or equal than specific seconds.</big><br>
    <h2><a name="mozTocId381935" class="mozTocH2"></a><big>Chapter 4. Collision</big></h2>
    <big> <span style="text-decoration: underline;"> An important thing for any
        game</span><br>
      <br>
      What is an important thing for a video games? A collision.<br>
      <br>
      <span style="text-decoration: underline;"> Collision detail</span><br>
      <br>
      Collision detector using bounding box collision method to detect
      collision. Collision related information store in special custom data
      type.<br>
      <br>
      <span style="font-style: italic;"> typedef struct</span><br style="font-style: italic;">
      <span style="font-style: italic;"> {</span><br style="font-style: italic;">
      &nbsp; <span style="font-style: italic;">unsigned int x;</span><br style="font-style: italic;">
      &nbsp; <span style="font-style: italic;"> unsigned int y;</span><br style="font-style: italic;">
      &nbsp; <span style="font-style: italic;"> unsigned int width;</span><br style="font-style: italic;">
      &nbsp; <span style="font-style: italic;"> unsigned int height;</span><br
        style="font-style: italic;">
      <span style="font-style: italic;"> } BOX;</span><br>
      <br>
      <span style="text-decoration: underline;"> Work with collision detector</span><br>
      <br>
      <span style="font-style: italic;"> Collision</span> class provide easy
      access to collision detector. It is a simple class with few methods. Let's
      look at public methods.<br>
      <br>
      <span style="font-style: italic;">Collision* Collision::get_handle();</span>
      – Return the handle to the collision detector.<br>
    </big><br>
    <big><span style="font-style: italic;">void Collision::set_target(const
        SWGF::BOX first_target,const SWGF::BOX second_target);</span>
      – Set targets for collision detector.<br>
      <br>
      <span style="font-style: italic;"> bool Collision::check_collision()
        const;</span> – Return true if collision between two objects is
      accepted.<br>
      <br>
      <span style="font-style: italic;"> bool Collision::check_collision(const
        SWGF::BOX first_target,const SWGF::BOX second_target);</span>
      – Set collision targets and check collision between it.<br>
    </big>
    <h2><a class="mozTocH2" name="mozTocId828077"></a><big>Chapter 5. Tile–map</big></h2>
    <big><span style="text-decoration: underline;">A few words about tile-map</span><br>
      <br>
      The tile–map is tile matrix. A tile is a small non–transparent sprite. A
      tile–map is very useful thing for level background.<br>
      <br style="text-decoration: underline;">
      <span style="text-decoration: underline;">Rows and columns</span><br>
      <br>
      First row index is 0. First column index is 0.<br>
      <br>
      <span style="text-decoration: underline;">Work with tile-map</span><br>
      <br>
      <span style="font-style: italic;">Tilemap</span> class provide easy access
      to the tile–map. It is a simple class with few methods. Let's look at
      public methods.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">Tilemap* Tilemap::get_handle();</span> –
      Return the handle to tile-map subsystem.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">void Tilemap::initialize(const unsigned
        int tile_width,const unsigned int tile_height);</span> – Initialize the
      subsystem.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Tilemap::get_tile_width()
        const;</span> – Return the tile width in pixels.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Tilemap::get_tile_height()
        const;</span> – Return the tile height in pixels.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_x(const
        unsigned int row) const;</span> – Get x-coordinate from target row.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_y(const
        unsigned int column) const;</span> – Get y-coordinate from target
      column.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int Tilemap::get_row(const
        unsigned int x) const;</span> – Get the row from x-coordinate.<br>
      <br>
      <span style="font-style: italic;">unsigned int Tilemap::get_column(const
        unsigned int y) const;</span> – Get the column from y-coordinate.<br>
      <br>
      <span style="font-style: italic;">unsigned int
        Tilemap::get_row_amount(const unsigned int viewport_width) const;</span>
      – Get amount of maximum visible rows.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">unsigned int
        Tilemap::get_column_amount(const unsigned int viewport_width) const;</span>
      – Get amount of maximum visible columns.<br>
      <br>
      <span style="font-style: italic;">unsigned int
        Tilemap::get_tile_amount(const unsigned int viewport_width,const
        unsigned int viewport_height) const;</span> – Get amount of maximum
      visible tiles.<br>
      <br>
      <span style="font-style: italic;">bool Tilemap::check_row(const unsigned
        int row,const unsigned int viewport_width) const;</span> – Return true
      if the row is valid.<br>
      <br>
      <span style="font-style: italic;">bool Tilemap::check_column(const
        unsigned int column,const unsigned int viewport_height) const;</span> –
      Return true if the column is valid.<br>
      <br>
      <span style="font-style: italic;">SWGF::BOX Tilemap::get_box(const
        unsigned int row,const unsigned int column) const;</span> – Return
      collision related information.<br>
    </big>
    <h1><a name="mozTocId611237" class="mozTocH1"></a><big>Part 6. Other
        important things</big></h1>
    <h2><a name="mozTocId648026" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>All subsystems in this section declared in <span style="font-style: italic;">Misc</span>
      sub–namespace.<br>
    </big>
    <h2><a name="mozTocId909723" class="mozTocH2"></a><big>Chapter 2. Memory</big></h2>
    <big>RAM is an important resource. Just use <span style="font-style: italic;">Memory</span>
      class to get total memory size and free memory size. Let's look at public
      methods.<br>
      <br>
      <span style="font-style: italic;"> unsigned long long int
        Memory::get_total_physical();</span> – Return total physical memory size
      in bytes.<br>
      <br>
      <span style="font-style: italic;"> unsigned long long int
        Memory::get_free_physical();</span> – Return free physical memory size
      in bytes.<br>
      <br>
      <span style="font-style: italic;"> unsigned long long int
        Memory::get_total_virtual();</span> – Return total <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual
        memory</a> size in bytes.<br>
      <br>
      <span style="font-style: italic;"> unsigned long long int
        Memory::get_free_virtual();</span> – Return free <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual
        memory</a> size in bytes.<br>
      <br>
      <span style="font-style: italic;"> unsigned long int Memory::get_usage();</span>
      – Return percentage of physical memory usage. <br>
    </big>
    <h2><a name="mozTocId950985" class="mozTocH2"></a><big>Chapter 3. Audio</big></h2>
    <big><span style="text-decoration: underline;"></span><span style="text-decoration: underline;">A
        few words about sound subsystem</span><br>
      <br>
      Audio subsystem intend for playing music and sounds. <a href="https://en.wikipedia.org/wiki/WAV">Waveform
        Audio File Format</a>, <a href="https://en.wikipedia.org/wiki/MP3">MPEG
        Audio Layer 3</a> and <a href="https://en.wikipedia.org/wiki/Windows_Media_Audio">Windows
        Media Audio</a> are supported.<br>
    </big><big><br>
      <span style="text-decoration: underline;"> Additional formats</span><br>
      <br>
      You can use an additional format if you install third–party codecs.<br>
      <br>
      <span style="text-decoration: underline;"> Working with sound</span><br>
      <br>
      Just use <span style="font-style: italic;">Audio</span> class to work
      with sound. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;"> void Audio::initialize();</span> –
      Initialize the subsystem.<br>
      <br>
      <span style="font-style: italic;"> void Audio::initialize(const char
        *target);</span> – Initialize the subsystem and load a sound file.<br>
      <br>
      <span style="font-style: italic;"> void Audio::load(const char *target);</span>
      – Load a sound file.<br>
      <br>
      <span style="font-style: italic;"> void Audio::play();</span> – Play a
      content of the target file.<br>
      <br>
      <span style="font-style: italic;"> void Audio::play_loop();</span> –
      Checking play status and restart play if needed.<br>
      <br>
      <span style="font-style: italic;">void Audio::play(const bool loop);</span>
      – Play a sound. You can set loop flag as true for loop playing mode.<br>
      <br>
      <span style="font-style: italic;"> void Audio::stop();</span> – Stop
      playing a content of the target file.<br>
      <br>
      <span style="font-style: italic;"> bool Audio::check_playing();</span> –
      Return true if the sound resource is playing.</big><br>
    <big> </big>
    <h1><a name="mozTocId209024" class="mozTocH1"></a><big>Part 7. Misc</big></h1>
    <h2><a name="mozTocId608755" class="mozTocH2"></a><big>Chapter 1. File
        system</big></h2>
    <big> File system subsystem implement as two simple functions. All these
      functions declared in <span style="font-style: italic;">Filesystem</span>
      sub–namespace.<br>
      <br>
      <span style="font-style: italic;"> file_exist</span> function check the
      target file for exist.<br>
      <br>
      <span style="font-style: italic;"> delete_file</span> function delete the
      target file.<br>
      <br>
      All functions take target file name as argument and return false if the
      operation failed.</big><br>
    <big> </big>
    <h2><a name="mozTocId59386" class="mozTocH2"></a><big>Chapter 2. Tools</big></h2>
    <big>This module implemented as few functions</big><big>. All these
      functions declared in <span style="font-style: italic;">Tools</span>
      sub–namespace.<br>
      <br>
      <span style="font-style: italic;">void quit();</span> </big><big>–</big><big>
      Exit from your program and return user to operating system.<br>
      <br>
      <span style="font-style: italic;">bool enable_logging(const char *name); </span></big><big>–</big><big><span
        style="font-style: italic;"></span> Enable redirecting error messages to
      a log file and return false if the operation failed.<br>
      <br>
      <span style="font-style: italic;">void randomize(); </span></big><big>–</big><big><span
        style="font-style: italic;"></span> Initialize random number generator.<br>
      <br>
      <span style="font-style: italic;">unsigned int get_random(const int
        number); </span></big><big>–</big><big><span style="font-style: italic;"></span>
      Return a random value between zero and the number.<br>
      <br>
      <span style="font-style: italic;"> unsigned int get_texture_size();</span>
    </big><big>–</big><big> Return maximum width or height of texture.<br>
      <br>
      <span style="font-style: italic;">SWGF::BOX generate_box(const unsigned
        int x,const unsigned int y,const unsigned int width,const unsigned int
        height);</span> – Generate collision related information.<br>
    </big>
    <h2><a name="mozTocId573582" class="mozTocH2"></a><big>Chapter 3. Resource
        manager</big></h2>
    <big>A resource is an instance of a user–defined class or structure.
      Resource manager is storage for resources. It implemented as few template
      functions. All these functions declared in <span style="font-style: italic;">Resource</span>
      sub–namespace.<br>
      <br>
      <span style="font-style: italic;"> create</span> function create single
      resource or terminate the program if operation failed. It didn't take
      argument and return handle of the resource.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;"> create_array</span> function create
      resource array or terminate the program if operation failed. It takes
      resource amount as argument and return handle of resource array.<br>
      <br>
      <span style="font-style: italic;"> destroy</span> function delete resource
      if it already exists. This function takes resource handle as argument.<br>
      <br>
      <span style="font-style: italic;"> destroy_array</span> function delete
      resource array if it already exists. This function takes resource array
      handle as argument.<br>
    </big>
    <h1><a name="mozTocId590919" class="mozTocH1"></a><big> Part 8. Binary files</big></h1>
    <h2><a name="mozTocId200879" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>All subsystems in this section declared in <span style="font-style: italic;">File</span>
      sub–namespace.</big><br>
    <big> </big>
    <h2><a name="mozTocId961921" class="mozTocH2"></a><big> Chapter 2. Base
        binary file subsystem</big></h2>
    <big> <br>
      <u> Work with binary files</u><br>
      <br>
      <i>Binary_File</i> class provide simple access to base binary subsystem.
      Don't use it directly. Let's look at public methods.<br>
      <br>
      <i> void Binary_File::close();</i> – Close the file.<br>
      <br>
      <i> void Binary_File::set_position(const long int offset);</i> – Set the
      file position.<br>
      <br>
      <i> long int Binary_File::get_position();</i> – Return current file
      position.<br>
      <br>
      <i> long int Binary_File::get_length();</i> – Return file length in bytes.<br>
      <br>
      <i> bool Binary_File::check_error();</i> – Return true if last file
      operation failed.<br>
      <br>
      <span style="font-style: italic;"> bool Binary_File::is_open() const;</span>
      – Return true if the file was successfully open.<br>
      <br>
      <u>Important notice</u><br>
      <br>
      Target file size limit is 2 gigabytes. </big>
    <h2><a name="mozTocId424835" class="mozTocH2"></a><big> Chapter 3. File
        reader</big></h2>
    <big> File reader is intending to reading data from a binary files. <i>Input_File</i>
      class provide access to file reader. It is derived from <i>Binary_File</i>
      class. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">Input_File* Input_File::get_handle();</span>
      – Return the handle to file reader.<br>
      <br>
      <i> void Input_File::open(const char *name);</i> – Open a file for read.<br>
      <br>
      <i> void Input_File::read(void *buffer,const size_t length);</i> – Read
      data from the file. </big>
    <h2><a name="mozTocId511135" class="mozTocH2"></a><big> Chapter 4. File
        writer</big></h2>
    <big> File writer is intending to write data to binary files. <i>Output_File</i>
      class provide access to file writer. It is derived from <i>Binary_File</i>
      class. Let's look at public methods.<br>
      <br style="font-style: italic;">
      <span style="font-style: italic;">Output_File* Output_File::get_handle();</span>
      – Return the handle to file writer.<br>
      <br>
      <i> void Output_File::open(const char *name);</i> – Open a file for write.<br>
      <br>
      <i> void Output_File::create_temp();</i> – Create a temporary file. This
      file will be deleted when it closed.<br>
      <br>
    </big> <big> <i> void Output_File::write(const void *buffer,const size_t
        length);</i> – Write data to the file.<br>
      <br>
    </big> <big><i>void Output_File::flush();</i> – Force writing internal
      buffer data to the file.</big><br>
    <big> </big>
    <h1><a name="mozTocId291572" class="mozTocH1"></a><big>Part 9. Input</big></h1>
    <h2><a name="mozTocId783369" class="mozTocH2"></a><big>Chapter 1. The
        sub–namespace</big></h2>
    <big>All subsystems in this section declared in <span style="font-style: italic;">Input</span>
      sub–namespace.</big><br>
    <big> </big>
    <h2><a name="mozTocId685403" class="mozTocH2"></a><big>Chapter 2. Keyboard</big></h2>
    <big> <span style="text-decoration: underline;"> Low–level input</span><br>
      <br>
      Any keyboard has a built–in chip. It generates a special code when user
      press or release key. This code called «scan code».<br>
      <br>
      <span style="text-decoration: underline;"> Working with keyboard</span><br>
      <br>
      Just use <span style="font-style: italic;">Keyboard</span> class to work
      with a keyboard. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;"> void Keyboard::initialize();</span> –
      Initialize the subsystem.<br>
      <br>
      <span style="font-style: italic;"> bool Keyboard::check_hold(const
        unsigned char code);</span> – Return true if key with specific scan–code
      is press or holding.<br>
      <br>
      <span style="font-style: italic;"> bool Keyboard::check_press(const
        unsigned char code);</span> – Return true if key with specific scan–code
      was press.<br>
      <br>
      <span style="font-style: italic;"> bool Keyboard::check_release(const
        unsigned char code);</span> – Return true if key with specific scan–code
      was release.<br>
      <br>
      <span style="font-style: italic;"> bool Keyboard::is_ready() const;</span>
      – Return true if the subsystem is already initialized.<br>
      <br>
      <span style="text-decoration: underline;"> List of supported scan–codes</span><br>
    </big>
    <p><big> You can see a list of scan–codes below.</big></p>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key </big></td>
          <td><big>Code </big></td>
          <td><big>Key </big></td>
          <td><big>Code </big></td>
          <td><big>Key </big></td>
          <td><big>Code </big></td>
        </tr>
        <tr>
          <td><big>Escape </big></td>
          <td><big>1 </big></td>
          <td><big>A </big></td>
          <td><big>30 </big></td>
          <td><big>F1 </big></td>
          <td><big>59 </big></td>
        </tr>
        <tr>
          <td><big>! or 1 </big></td>
          <td><big>2 </big></td>
          <td><big>S </big></td>
          <td><big>31 </big></td>
          <td><big>F2</big></td>
          <td><big>60 </big></td>
        </tr>
        <tr>
          <td><big>@ or 2 </big></td>
          <td><big>3 </big></td>
          <td><big>D </big></td>
          <td><big>32 </big></td>
          <td><big>F3</big></td>
          <td><big>61 </big></td>
        </tr>
        <tr>
          <td><big># or 3 </big></td>
          <td><big>4 </big></td>
          <td><big>F </big></td>
          <td><big>33 </big></td>
          <td><big>F4</big></td>
          <td><big>62 </big></td>
        </tr>
        <tr>
          <td><big>$ or 4 </big></td>
          <td><big>5 </big></td>
          <td><big>G </big></td>
          <td><big>34 </big></td>
          <td><big>F5</big></td>
          <td><big>63 </big></td>
        </tr>
        <tr>
          <td><big>% or 5 </big></td>
          <td><big>6 </big></td>
          <td><big>H </big></td>
          <td><big>35 </big></td>
          <td><big>F6</big></td>
          <td><big>64 </big></td>
        </tr>
        <tr>
          <td><big>^ or 6 </big></td>
          <td><big>7 </big></td>
          <td><big>J </big></td>
          <td><big>36 </big></td>
          <td><big>F7</big></td>
          <td><big>65 </big></td>
        </tr>
        <tr>
          <td><big>&amp; or 7 </big></td>
          <td><big>8 </big></td>
          <td><big>K </big></td>
          <td><big>37 </big></td>
          <td><big>F8</big></td>
          <td><big>66 </big></td>
        </tr>
        <tr>
          <td><big>* or 8 </big></td>
          <td><big>9 </big></td>
          <td><big>L </big></td>
          <td><big>38 </big></td>
          <td><big>F9</big></td>
          <td><big>67 </big></td>
        </tr>
        <tr>
          <td><big>( or 9 </big></td>
          <td><big>10 </big></td>
          <td><big>: or ;</big></td>
          <td><big>39 </big></td>
          <td><big>F10</big></td>
          <td><big>68 </big></td>
        </tr>
        <tr>
          <td><big>0 or ) </big></td>
          <td><big>11 </big></td>
          <td><big>" or ' </big></td>
          <td><big>40 </big></td>
          <td><big>F11</big></td>
          <td><big>133 </big></td>
        </tr>
        <tr>
          <td><big>_ or – </big></td>
          <td><big>12 </big></td>
          <td><big>~ or ` </big></td>
          <td><big>41 </big></td>
          <td><big>F12</big></td>
          <td><big>134 </big></td>
        </tr>
        <tr>
          <td><big>+ or = </big></td>
          <td><big>13 </big></td>
          <td><big>Left Shift </big></td>
          <td><big>42 </big></td>
          <td><big>Num Lock </big></td>
          <td><big>69 </big></td>
        </tr>
        <tr>
          <td><big>Backspace </big></td>
          <td><big>14 </big></td>
          <td><big>| or \ </big></td>
          <td><big>43 </big></td>
          <td><big>Scroll Lock </big></td>
          <td><big>70 </big></td>
        </tr>
        <tr>
          <td><big>Tab </big></td>
          <td><big>15 </big></td>
          <td><big>Z </big></td>
          <td><big>44 </big></td>
          <td><big>Home or 7 </big></td>
          <td><big>71 </big></td>
        </tr>
        <tr>
          <td><big>Q </big></td>
          <td><big>16 </big></td>
          <td><big>X </big></td>
          <td><big>45 </big></td>
          <td><big>Up or 8 </big></td>
          <td><big>72 </big></td>
        </tr>
        <tr>
          <td><big>W </big></td>
          <td><big>17 </big></td>
          <td><big>C </big></td>
          <td><big>46 </big></td>
          <td><big>Page up or 9 </big></td>
          <td><big>73 </big></td>
        </tr>
        <tr>
          <td><big>E </big></td>
          <td><big>18 </big></td>
          <td><big>V </big></td>
          <td><big>47 </big></td>
          <td><big>Gray – </big></td>
          <td><big>74 </big></td>
        </tr>
        <tr>
          <td><big>R </big></td>
          <td><big>19 </big></td>
          <td><big>B </big></td>
          <td><big>48 </big></td>
          <td><big>Left or 4 </big></td>
          <td><big>75 </big></td>
        </tr>
        <tr>
          <td><big>T </big></td>
          <td><big>20 </big></td>
          <td><big>N </big></td>
          <td><big>49 </big></td>
          <td><big>Center or 5 </big></td>
          <td><big>76 </big></td>
        </tr>
        <tr>
          <td><big>Y </big></td>
          <td><big>21 </big></td>
          <td><big>M </big></td>
          <td><big>50 </big></td>
          <td><big>Right or 6 </big></td>
          <td><big>77 </big></td>
        </tr>
        <tr>
          <td><big>U </big></td>
          <td><big>22 </big></td>
          <td><big>&lt; or , </big></td>
          <td><big>51 </big></td>
          <td><big>Gray + </big></td>
          <td><big>78 </big></td>
        </tr>
        <tr>
          <td><big>I </big></td>
          <td><big>23 </big></td>
          <td><big>&gt; or . </big></td>
          <td><big>52 </big></td>
          <td><big>End or 1 </big></td>
          <td><big>79 </big></td>
        </tr>
        <tr>
          <td><big>O </big></td>
          <td><big>24 </big></td>
          <td><big>? or / </big></td>
          <td><big>53 </big></td>
          <td><big>Down or 2 </big></td>
          <td><big>80 </big></td>
        </tr>
        <tr>
          <td><big>P </big></td>
          <td><big>25 </big></td>
          <td><big>Right shift </big></td>
          <td><big>54 </big></td>
          <td><big>Page down or 3 </big></td>
          <td><big>81 </big></td>
        </tr>
        <tr>
          <td><big>{ or [ </big></td>
          <td><big>26 </big></td>
          <td><big>Print Screen or * </big></td>
          <td><big>55 </big></td>
          <td><big>Insert or 0 </big></td>
          <td><big>82 </big></td>
        </tr>
        <tr>
          <td><big>} or ] </big></td>
          <td><big>27 </big></td>
          <td><big>Alt </big></td>
          <td><big>56 </big></td>
          <td><big>Delete or . </big></td>
          <td><big>83 </big></td>
        </tr>
        <tr>
          <td><big>Enter </big></td>
          <td><big>28 </big></td>
          <td><big>Spacebar </big></td>
          <td><big>57 </big></td>
          <td><big> </big><br>
          </td>
          <td><big> </big><br>
          </td>
        </tr>
        <tr>
          <td><big>Control </big></td>
          <td><big>29 </big></td>
          <td><big>Caps Lock </big></td>
          <td><big>58 </big></td>
          <td><big> </big><br>
          </td>
          <td><big> </big><br>
          </td>
        </tr>
      </tbody>
    </table>
    <big> </big>
    <h2><a name="mozTocId686993" class="mozTocH2"></a><big>Chapter 3. Mouse</big></h2>
    <big> <span style="text-decoration: underline;"> A few words about mouse</span><br>
      <br>
      Mouse is very useful for interaction with graphical user interface. But
      mouse also can use in a video games.<br>
      <br>
      <span style="text-decoration: underline;"> Working with mouse</span><br>
      <br>
      Just use <span style="font-style: italic;">Mouse</span> class to work
      with a mouse. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;"> void Mouse::show();</span> – Show mouse
      cursor.<br>
      <br>
      <span style="font-style: italic;"> void Mouse::hide();</span> – Hide mouse
      cursor.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Mouse::get_x();</span> –
      Return x position of mouse.<br>
      <br>
      <span style="font-style: italic;"> unsigned int Mouse::get_y();</span> –
      Return y position of mouse.<br>
      <br>
      <span style="font-style: italic;"> void Mouse::set_position(const unsigned
        int x,const unsigned int y);</span> – Set position of mouse.<br>
      <br>
      <span style="font-style: italic;"> bool Mouse::check_hold(const
        SWGF::MOUSE_BUTTON button);</span> – Return true if specific mouse
      button is press or holding.<br>
      <br>
      <span style="font-style: italic;"> bool Mouse::check_press(const
        SWGF::MOUSE_BUTTON button);</span> – Return true if specific mouse
      button was press.<br>
      <br>
      <span style="font-style: italic;"> bool Mouse::check_release(const
        SWGF::MOUSE_BUTTON button);</span> – Return true if specific mouse
      button was release.<br>
      <br>
      <span style="text-decoration: underline;"> Mouse buttons</span><br>
    </big>
    <p><big> Mouse button codes look as predefined constants. You can see it
        below.</big></p>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Mouse button code </big></td>
          <td><big>Button </big></td>
        </tr>
        <tr>
          <td><big>MOUSE_LEFT </big></td>
          <td><big>Left button </big></td>
        </tr>
        <tr>
          <td><big>MOUSE_RIGHT </big></td>
          <td><big>Right button </big></td>
        </tr>
        <tr>
          <td><big>MOUSE_MIDDLE </big></td>
          <td><big>Middle button </big></td>
        </tr>
      </tbody>
    </table>
    <big> </big>
    <h2><a name="mozTocId861609" class="mozTocH2"></a><big>Chapter 4. Game–pad</big></h2>
    <big> <span style="text-decoration: underline;"> Best friend of retro gamer</span><br>
      <br>
      What is good choice for game control device when user play in arcade or
      old–school style video–game? A game–pad. This engine provides simple
      access to a game–pads.<br>
      <br>
      <span style="text-decoration: underline;"> Numbers of connect game–pads</span><br>
      <br>
      You can connect a few game–pads. Any connected game–pad have an internal
      index. First game–pad is 0. Maximum amount of connected game-pad is 4.
      First game–pad will activate by default at program start.<br>
      <br style="text-decoration: underline;">
      <span style="text-decoration: underline;">Buttons codes</span><br>
    </big>
    <p><big>Buttons codes look as predefined constants. You can see it below.</big></p>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Button code </big></td>
          <td><big>Description </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_UP </big></td>
          <td><big>D–pad up </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_DOWN </big></td>
          <td><big>D–pad down </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_LEFT </big></td>
          <td><big>D–pad left </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_RIGHT </big></td>
          <td><big>D–pad right </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_A </big></td>
          <td><big>A </big><br>
          </td>
        </tr>
        <tr>
          <td><big>GAMEPAD_B </big></td>
          <td><big>B&nbsp;</big><br>
          </td>
        </tr>
        <tr>
          <td><big>GAMEPAD_X </big></td>
          <td><big>X </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_Y </big></td>
          <td><big>Y </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>GAMEPAD_LEFT_BUMPER<br>
            </big></td>
          <td style="vertical-align: top;"><big>Left bumper<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>GAMEPAD_RIGHT_BUMPER<br>
            </big></td>
          <td style="vertical-align: top;"><big>Right bumper<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>GAMEPAD_START<br>
            </big></td>
          <td style="vertical-align: top;"><big>Start<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>GAMEPAD_BACK<br>
            </big></td>
          <td style="vertical-align: top;"><big>Back<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <span style="text-decoration: underline;">Sticks identifiers</span><br>
    </big>
    <p><big> Sticks identifiers look as predefined constants. You can see it
        below.</big></p>
    <big> </big>
    <table style="width: 351px; height: 139px;" border="1">
      <tbody>
        <tr>
          <td><big>Identifiers </big></td>
          <td><big>Description </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_LEFT_STICK </big></td>
          <td><big>Left stick </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_RIGHT_STICK </big></td>
          <td><big>Right stick </big></td>
        </tr>
      </tbody>
    </table>
    <br>
    <big><span style="text-decoration: underline;">Triggers identifiers</span><br>
      <br>
      Triggers identifiers look as predefined constants. You can see it below.<br>
      <br>
    </big>
    <table style="text-align: left; width: 366px; height: 91px;" cellspacing="2"

      cellpadding="2" border="1">
      <tbody>
        <tr>
          <td style="vertical-align: top;"><big>Identifiers<br>
            </big></td>
          <td style="vertical-align: top;"><big>Description<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>GAMEPAD_LEFT_TRIGGER<br>
            </big></td>
          <td style="vertical-align: top;"><big>Left trigger<br>
            </big></td>
        </tr>
        <tr>
          <td style="vertical-align: top;"><big>GAMEPAD_RIGHT_TRIGGER<br>
            </big></td>
          <td style="vertical-align: top;"><big>Right trigger<br>
            </big></td>
        </tr>
      </tbody>
    </table>
    <big><span style="text-decoration: underline;"></span></big><br>
    <big> <span style="text-decoration: underline;"> Stick direction</span><br>
    </big>
    <p><big> Stick direction look as predefined constants. You can see it below.</big></p>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Value </big></td>
          <td><big>X–direction </big></td>
          <td><big>Y–direction </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_NEUTRAL_DIRECTION </big></td>
          <td><big>Neutral </big></td>
          <td><big>Neutral </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_POSITIVE_DIRECTION </big></td>
          <td><big>Right </big></td>
          <td><big>Up </big></td>
        </tr>
        <tr>
          <td><big>GAMEPAD_NEGATIVE_DIRECTION </big></td>
          <td><big>Left </big></td>
          <td><big>Down </big></td>
        </tr>
      </tbody>
    </table>
    <big><br>
      <span style="text-decoration: underline;"> Working with game–pad</span><br>
      <br>
      Just use <span style="font-style: italic;">Gamepad</span> class to work
      with game–pad. Let's look at public methods.<br>
      <br>
      <span style="font-style: italic;">void Gamepad::set_active(const unsigned
        int gamepad);</span> – Set current active game-pad. Always call it after
      get amount of connected game-pads.<br>
      <br>
      <span style="font-style: italic;">unsigned int Gamepad::get_amount();</span>
      – Return amount of connected game-pads.<br>
      <br>
      <span style="font-style: italic;">unsigned int Gamepad::get_active()
        const;</span> – Return identifer of current active game-pad.<br>
      <span style="font-style: italic;"></span><br>
      <span style="font-style: italic;">bool Gamepad::check_connection();</span>
      – Return true if active game-pad is connected.<br>
      <br>
      <span style="font-style: italic;">void Gamepad::update();</span> – Update
      game-pad state.<br>
      <br>
      <span style="font-style: italic;">bool Gamepad::check_button_hold(const
        SWGF::GAMEPAD_BUTTONS button) const;</span> – Return true if a button of
      active game-pad is pressed or holding.<br>
      <br>
      <span style="font-style: italic;">bool Gamepad::check_button_press(const
        SWGF::GAMEPAD_BUTTONS button) const;</span> – Return true if a button of
      active game-pad is pressed.<br>
      <br>
      <span style="font-style: italic;">bool
        Gamepad::check_button_released(const SWGF::GAMEPAD_BUTTONS button)
        const;</span> – Return true if a button of active game-pad is released.<br>
      <br>
      <span style="font-style: italic;">bool Gamepad::check_trigger_hold(const
        SWGF::GAMEPAD_TRIGGERS trigger) const;</span> – Return true if specific
      trigger of active game-pad is pressed or holding.<br>
      <br>
      <span style="font-style: italic;">bool Gamepad::check_trigger_press(const
        SWGF::GAMEPAD_TRIGGERS trigger) const;</span> – Return true if specific
      trigger of active game-pad is pressed.<br>
      <br>
      <span style="font-style: italic;">bool
        Gamepad::check_trigger_release(const SWGF::GAMEPAD_TRIGGERS trigger)
        const;</span> – Return true if specific trigger of active game-pad is
      released.<br>
      <span style="font-style: italic;"></span><br>
      <span style="font-style: italic;">unsigned char
        Gamepad::get_left_trigger() const;</span> – Return current value of left
      analog trigger.<br>
      <br>
      <span style="font-style: italic;">unsigned char
        Gamepad::get_right_trigger() const;</span> – Return current value of
      right analog trigger.<br>
      <br>
      <span style="font-style: italic;">GAMEPAD_DIRECTION
        Gamepad::get_stick_x(const SWGF::GAMEPAD_STICKS stick) const;</span> –
      Return x-direction of specific stick.<br>
      <br>
      <span style="font-style: italic;">GAMEPAD_DIRECTION
        Gamepad::get_stick_y(const SWGF::GAMEPAD_STICKS stick) const;</span> –
      Return y-direction of specific stick.<br>
      <br>
      <span style="font-style: italic;">GAMEPAD_DIRECTION
        Gamepad::get_left_stick_x() const;</span> – Return x-direction of left
      stick.<br>
      <br>
      <span style="font-style: italic;">GAMEPAD_DIRECTION
        Gamepad::get_left_stick_y() const;</span> – Return y-direction of left
      stick.<br>
      <br>
      <span style="font-style: italic;">GAMEPAD_DIRECTION
        Gamepad::get_right_stick_x() const;</span> – Return x-direction of right
      stick.<br>
      <br>
      <span style="font-style: italic;">GAMEPAD_DIRECTION
        Gamepad::get_right_stick_y() const;</span> – Return y-direction of right
      stick.<br>
      <br>
      <span style="font-style: italic;">bool Gamepad::set_vibration(const
        unsigned short int left,const unsigned short int right);</span> – Set
      vibration level for rumble motors(left and right) of active game-pad.
      Vibration level is value from 0 to 65535. Return false if operation was
      fail.<br>
      <br>
      <span style="font-style: italic;">bool Gamepad::disable_vibration();</span>
      – Disable vibration of active game-pad. Return false if operation was
      fail.<br>
      <br>
      <span style="font-style: italic;">nsigned short int
        Gamepad::get_left_motor() const;</span> – Return vibration level of left
      rumble motor.<br>
      <br>
      <span style="font-style: italic;">nsigned short int
        Gamepad::get_right_motor() const;</span> – Return vibration level of
      right rumble motor.<br>
    </big>
    <h1><a name="mozTocId309127" class="mozTocH1"></a><big>Part 10. Internal
        details of the engine subsystems</big></h1>
    <big></big> <big> </big>
    <h2><a name="mozTocId383177" class="mozTocH2"></a><big>Chapter 1. A few
        words for a curious programmer</big></h2>
    <big> The engine subsystems have a different internal structure. It has
      hidden from you, and you don't have access to it. Do you want to know
      about hiding things? Just read a next chapter.</big><br>
    <big> </big>
    <h2><a name="mozTocId318160" class="mozTocH2"></a><big>Chapter 2. Internal
        classes</big></h2>
    <big><span style="text-decoration: underline;">Internal classes</span><br>
      <br>
      Some classes designed for internal use only. Don't touch them. What doing
      these strange classes?<br>
      <br>
      <span style="text-decoration: underline;"> Microsoft Windows specific
        classes</span><br>
      <br>
      All Microsoft Windows specific classes declared in <span style="font-style: italic;">Internal</span>
      sub–namespace.<br>
      <br>
      <span style="font-style: italic;"> Engine</span> creates the game window
      and do message processing.<br>
      <span style="font-style: italic;"> Synchronization</span> implements the
      synchronization timer.<br>
      <span style="font-style: italic;"> Display</span> implement display
      manager.<br>
    </big> <big><span style="font-style: italic;"> WINGL</span> contain Windows
      specific OPENGL initialization code.</big><br>
    <big><br style="text-decoration: underline;">
      <span style="text-decoration: underline;"> Core classes</span><br>
      <br>
      All engine core classes and functions declared in <span style="font-style: italic;">Core</span>
      sub–namespace.<br>
      <br>
    </big> <big><span style="font-style: italic;"> FPS</span> implement fps
      counter.<br>
    </big><big><i>Unicode_Convertor</i> implement system code–page to UTF–16
      convertor.<br>
      <span style="font-style: italic;"> Buffer</span> implement custom memory
      buffer.<br>
    </big><big><span style="font-style: italic;"> Render</span> implement OPENGL
      render.<br>
      <span style="font-style: italic;"> Resizer</span> intending to calculate
      correct texture size.<br>
      <span style="font-style: italic;"> Rectangle</span> intending to draw
      textured rectangle.<br>
      <span style="font-style: italic;"> Shape</span> is base class of <span style="font-style: italic;">Rectangle</span>
      class.<br>
    </big>
    <h2><a name="mozTocId293644" class="mozTocH2"></a><big>Chapter 3. Base
        graphics subsystem</big></h2>
    <big> </big><big style="text-decoration: underline;">Visible object</big><br>
    <big> </big><br>
    <big> Any visible object is a textured rectangle.</big><br>
    <big> </big><br>
    <big style="text-decoration: underline;"> Images</big><br>
    <big> </big><br>
    <big> A texture width must be a power of two. A texture height also must be
      a power of two. Any image will automatically resize before load.</big><br>
    <br>
    <big style="text-decoration: underline;"> Vertex arrays and texture
      coordinates arrays</big><br>
    <big> </big><br>
    <big> Any rectangle need four vertexes and four texture coordinates.</big><br>
    <big> Single vertex represent by follow custom data type.</big><br>
    <big> </big><br>
    <big style="font-style: italic;"> typedef struct Vertex</big><br style="font-style: italic;">
    <big style="font-style: italic;"> {</big><br style="font-style: italic;">
    &nbsp; <big style="font-style: italic;">int x;</big><br style="font-style: italic;">
    &nbsp; <big style="font-style: italic;"> int y;</big><br style="font-style: italic;">
    <big style="font-style: italic;"> };</big><br>
    <big> </big><br>
    <big> </big><big>Single texture coordinate represent by follow custom data
      type.</big><br>
    <big> </big><br>
    <big style="font-style: italic;"> typedef struct</big><br style="font-style: italic;">
    <big style="font-style: italic;"> {</big><br style="font-style: italic;">
    &nbsp; <big style="font-style: italic;">float u;</big><br style="font-style: italic;">
    &nbsp; <big style="font-style: italic;">float v;</big><br style="font-style: italic;">
    <big style="font-style: italic;"> } Point;</big><br>
    <big> </big> <br>
    <big>All these custom types declared in <span style="font-style: italic;">Core</span>
      sub–namespace.</big><br>
    <big> </big>
    <h2><a name="mozTocId472209" class="mozTocH2"></a><big>Chapter 4. Game–pad</big></h2>
    <big> Game–pad subsystem working over <a href="https://docs.microsoft.com/en-us/windows/desktop/xinput/xinput-game-controller-apis-portal">XINPUT</a>.
      It available as part of DirectX. XInput support by Xbox 360 controller or
      compatible devices. </big>
    <h2><a name="mozTocId804583" class="mozTocH2"></a><big>Chapter 5. Input</big></h2>
    <big><br style="text-decoration: underline;">
      <span style="text-decoration: underline;"> Input back–end</span><br>
      <br>
      Keyboard and mouse input subsystems are simple. It works over standard
      Windows API.<br>
      <br>
      <span style="text-decoration: underline;"> Internal key state</span><br>
    </big>
    <p><big> Internal state of keyboard keys and mouse buttons look as
        predefined constants. You can see it below.</big></p>
    <big> </big>
    <table border="1">
      <tbody>
        <tr>
          <td><big>Key/button state </big></td>
          <td><big>Description </big></td>
        </tr>
        <tr>
          <td><big>KEY_PRESSED </big></td>
          <td><big>A key\button is press or holding </big></td>
        </tr>
        <tr>
          <td><big>KEY_RELEASED </big></td>
          <td><big>A key\button was release </big></td>
        </tr>
      </tbody>
    </table>
    <big> </big>
    <h2><a name="mozTocId692266" class="mozTocH2"></a><big>Chapter 6. Audio</big></h2>
    <big> Audio subsystem working over <a href="https://docs.microsoft.com/en-us/windows/desktop/DirectShow/directshow">DirectShow</a>.
      It is available as part of <a href="https://en.wikipedia.org/wiki/DirectX">DirectX</a>.
      DirectX is pre–installed by default under modern versions of Windows. </big>
    <h1><a name="mozTocId78453" class="mozTocH1"></a><big>Version history</big></h1>
    <big> 0.1 – 6.3.6 – Old branch.<br>
      6.3.7 – 6.5.1 – Experimental branch.<br>
      6.5.2 – Source code synced with Eugene game development kit 6.5.7.<br>
      6.5.3 – Small changes.<br>
      6.5.4 – Game-pad subsystem back-ported from Black game development kit 4.1.4.<br>
      6.5.5 – 6.6.6 – Game-pad subsystem improved.<br>
      6.6.6.1 – Documentation updated.<br>
      6.6.7 – Small changes.<br>
      6.6.8 – 6.7 – Game-pad subsystem improved.<br>
      6.7.1 – Source code synced with Eugene game development kit 6.6.1.<br>
      6.7.2 – Synchronization timer back-ported from Gray game development kit 2.3.5.<br>
      6.7.3 – Windows XP support removed.<br>
      6.7.4 – 6.7.5 – Small changes.<br>
      6.7.6 – Source code synced with Eugene game development kit 6.6.6.<br>
      6.7.7 – Source code synced with Eugene game development kit 6.7.<br>
      6.7.8 – Source code synced with Eugene game development kit 6.7.1.<br>
      6.7.9 – 6.8 – Game-pad subsystem improved.<br>
      6.8.1 – Source code synced with Eugene game development kit 6.7.6.<br>
      6.8.2 – Source code synced with Eugene game development kit 6.7.7.<br>
      6.8.3 – Source code synced with Eugene game development kit 6.7.8.<br>
      6.8.4 – Source code synced with Eugene game development kit 6.7.9.<br>
      6.8.5 – Source code synced with Eugene game development kit 6.8.<br>
      6.8.6 – Source code synced with Eugene game development kit 6.8.2.<br>
      6.8.7 – Source code synced with Eugene game development kit 6.8.4.<br>
      6.8.8 – Source code synced with Eugene game development kit 6.8.5.<br>
      6.8.9 – Source code synced with Eugene game development kit 6.8.6.<br>
      6.9 – Source code synced with Eugene game development kit 6.8.7.<br>
      6.9.1 – Source code synced with Black game development kit 4.4.7.<br>
      6.9.2 – Source code synced with Eugene game development kit 6.9.2.<br>
      6.9.3 – Source code synced with Neon game development kit 6.2.6.<br>
      6.9.4 – Synchronization timer improved.<br>
      6.9.5 – Source code synced with Eugene game development kit 6.9.4.<br>
      6.9.6 – Source code synced with Neon game development kit 6.3.4.<br>
      6.9.7 – Source code synced with Eugene game development kit 6.9.9.<br>
      6.9.8 – Source code synced with Neon game development kit 6.3.7.<br>
      6.9.9 – Source code synced with Eugene game development kit 7.0.1.<br>
      7.0 – Source code synced with Eugene game development kit 7.0.2.<br>
      7.0.1 – 7.0.2 – Small changes.<br>
      7.0.3 – Image resizer improved.<br>
      7.0.4 – 7.0.7 – Small changes.<br>
      7.0.8 – Source code synced with Eugene game development kit 7.1.8.<br>
      7.0.9 – Source code synced with Eugene game development kit 7.1.9.<br>
      7.1 – Source code synced with Eugene game development kit 7.2.<br>
      7.1.1 – Source code synced with Eugene game development kit 7.2.1.<br>
      7.1.2 – Source code synced with Eugene game development kit 7.2.2.<br>
      7.1.3 – Source code synced with Eugene game development kit 7.2.4.<br>
      7.1.4 – 7.1.5 – Image resizer improved.<br>
      7.1.6 – Source code synced with Eugene game development kit 7.2.5.<br>
      7.1.7 – Source code synced with Eugene game development kit 7.2.6.<br>
      7.1.8 – Source code synced with Eugene game development kit 7.2.7.<br>
      7.1.9 – Source code synced with Eugene game development kit 7.2.8.<br>
      7.2 – Source code synced with Eugene game development kit 7.2.9.<br>
      7.2.1 – Source code synced with Eugene game development kit 7.3.<br>
      7.2.2 – Source code synced with Eugene game development kit 7.3.1.<br>
      7.2.3 – Source code synced with Eugene game development kit 7.3.2.<br>
      7.2.4 – Source code synced with Eugene game development kit 7.3.3.<br>
      7.2.5 – Source code synced with Eugene game development kit 7.3.4.<br>
      7.2.6 – Source code synced with Eugene game development kit 7.3.5.<br>
      7.2.7 – 7.2.8 – Small changes.<br>
      7.2.9 – 7.3 – Image resizer improved.<br>
      7.3.1 – Small changes.<br>
      7.3.2 – 7.3.5 – Image resizer improved.<br>
      7.3.6 – Source code synced with Eugene game development kit 7.3.7.<br>
      7.3.7 – Source code synced with Eugene game development kit 7.4.4.<br>
      7.3.8 – Source code synced with Eugene game development kit 7.4.5.<br>
      7.3.9 – Source code synced with Eugene game development kit 7.5.<br>
      7.4 – Source code synced with Eugene game development kit 7.5.3.<br>
      7.4.1 – Source code synced with Eugene game development kit 7.5.4.<br>
      7.4.2 – Source code synced with Eugene game development kit 7.5.8.<br>
      7.4.3 – Source code synced with Eugene game development kit 7.6.3.<br>
      7.4.4 – Source code synced with Eugene game development kit 7.6.4.<br>
      7.4.5 – Source code synced with Eugene game development kit 7.6.5.<br>
      7.4.6 – Source code synced with Eugene game development kit 7.6.6.<br>
      7.4.7 – Source code synced with Eugene game development kit 7.6.8.<br>
      7.4.8 – Source code synced with Eugene game development kit 7.6.9.<br>
      7.4.9 – Source code synced with Eugene game development kit 7.7.<br>
      7.5 – Source code synced with Eugene game development kit 7.7.2.<br>
      7.5.1 – Source code synced with Eugene game development kit 7.7.3.<br>
      7.5.2 – Source code synced with Eugene game development kit 7.7.4.<br>
      7.5.3 – Source code synced with Eugene game development kit 7.7.5.<br>
      7.5.4 – Source code synced with Eugene game development kit 7.7.6.<br>
      7.5.5 – Source code synced with Eugene game development kit 7.8.<br>
      7.5.6 – Source code synced with Eugene game development kit 7.8.1.<br>
      7.5.7 – Source code synced with Eugene game development kit 7.8.2.<br>
      7.5.8 – Source code synced with Eugene game development kit 7.8.4.<br>
      7.5.9 – Source code synced with Eugene game development kit 7.8.5.<br>
      7.6 – Source code synced with Eugene game development kit 7.8.6.<br>
      7.6.1 – Source code synced with Eugene game development kit 7.8.8.<br>
      7.6.2 – Source code synced with Eugene game development kit 7.8.9.<br>
      7.6.3 – Source code synced with Eugene game development kit 7.9.<br>
      7.6.4 – Source code synced with Eugene game development kit 7.9.1.<br>
      7.6.5 – Source code synced with Eugene game development kit 7.9.2.<br>
      7.6.6 – Source code synced with Eugene game development kit 7.9.3.<br>
      7.6.7 – Source code synced with Eugene game development kit 7.9.4.<br>
      7.6.8 – Source code synced with Eugene game development kit 7.9.5.<br>
      7.6.9 – Source code synced with Eugene game development kit 7.9.6.<br>
      7.7 – Source code synced with Eugene game development kit 7.9.7.<br>
      7.7.1 – Source code synced with Eugene game development kit 7.9.8.<br>
      7.7.2 – Source code synced with Eugene game development kit 8.0.3.<br>
      7.7.3 – Source code synced with Eugene game development kit 8.0.4.<br>
      7.7.4 – Source code synced with Eugene game development kit 8.0.5.<br>
      7.7.5 – Source code synced with Eugene game development kit 8.0.8.<br>
      7.7.6 – Source code synced with Eugene game development kit 8.0.9.<br>
      7.7.7 – Source code synced with Eugene game development kit 8.1.4.<br>
      7.7.8 – Source code synced with Eugene game development kit 8.1.5.<br>
      7.7.9 – Source code synced with Eugene game development kit 8.1.6.<br>
      7.8 – Source code synced with Eugene game development kit 8.1.7.<br>
      7.8.1 – Source code synced with Eugene game development kit 8.1.8.<br>
      7.8.2 – Source code synced with Eugene game development kit 8.1.9.<br>
      7.8.3 – Source code synced with Eugene game development kit 8.2.1.<br>
      7.8.4 – Source code synced with Eugene game development kit 8.2.2.<br>
      7.8.5 – Source code synced with Eugene game development kit 8.2.3.<br>
      7.8.6 – Source code synced with Eugene game development kit 8.2.4.<br>
      7.8.7 – Source code synced with Eugene game development kit 8.2.5.<br>
      7.8.8 – Source code synced with Eugene game development kit 8.2.6.<br>
      7.8.9 – Source code synced with Eugene game development kit 8.2.8.<br>
      7.9 – Source code synced with Eugene game development kit 8.3.<br>
      7.9.1 – Source code synced with Eugene game development kit 8.3.1.<br>
      7.9.2 – Source code synced with Eugene game development kit 8.3.2.<br>
      7.9.3 – Source code synced with Eugene game development kit 8.3.3.<br>
      7.9.4 – Source code synced with Eugene game development kit 8.3.4.<br>
      7.9.5 – Source code synced with Neon game development kit 5.2.9.<br>
      7.9.6 – Source code synced with Neon game development kit 5.3.<br>
      7.9.7 – Source code synced with Neon game development kit 5.3.1.<br>
      7.9.8 – Source code synced with Neon game development kit 5.3.2.<br>
      7.9.9 – Source code synced with Neon game development kit 5.3.3.<br>
      8.0 – Source code synced with Eugene game development kit 8.4.1.<br>
      8.0.1 – Source code synced with Eugene game development kit 8.4.2.<br>
      8.0.2 – Source code synced with Eugene game development kit 8.4.3.<br>
      8.0.3 – Source code synced with Eugene game development kit 8.4.4.<br>
      8.0.4 – Source code synced with Eugene game development kit 8.4.5.<br>
      8.0.5 – Source code synced with Eugene game development kit 8.4.6.<br>
      8.0.6 – Source code synced with Eugene game development kit 8.4.8.<br>
      8.0.7 – Source code synced with Eugene game development kit 8.5.<br>
      8.0.8 – Source code synced with Eugene game development kit 8.5.5.<br>
      8.0.9 – Source code synced with Eugene game development kit 8.5.6.<br>
      8.1 – Source code synced with Eugene game development kit 8.5.7.<br>
      8.1.1 – Source code synced with Eugene game development kit 8.5.8.<br>
      8.1.2 – Source code synced with Eugene game development kit 8.5.9.<br>
      8.1.3 – Source code synced with Eugene game development kit 8.6.<br>
      8.1.4 – Source code synced with Eugene game development kit 8.6.1.<br>
      8.1.5 – Source code synced with Black game development kit 5.5.7.<br>
      8.1.6 – Source code synced with Eugene game development kit 8.6.2.<br>
      8.1.7 – Source code synced with Eugene game development kit 8.6.3.<br>
      8.1.8 – Source code synced with Eugene game development kit 8.6.5.<br>
      8.1.9 – Source code synced with Eugene game development kit 8.6.6.<br>
      8.2 – Source code synced with Eugene game development kit 8.6.8.<br>
      8.2.1 – Source code synced with Gray game development kit 3.7.7.<br>
      8.2.2 – Source code synced with Eugene game development kit 8.6.9.<br>
      8.2.3 – Source code synced with Eugene game development kit 8.7.1.<br>
      8.2.4 – Source code synced with Eugene game development kit 8.7.2.<br>
      8.2.5 – Source code synced with Eugene game development kit 8.7.3.<br>
      8.2.6 – Source code synced with Eugene game development kit 5.6.8.<br>
      8.2.7 – Source code synced with Black game development kit 5.6.9.<br>
      8.2.8 – Source code synced with Eugene game development kit 8.7.6.<br>
      8.2.9 – Source code synced with Eugene game development kit 8.7.7.<br>
      8.3 – Source code synced with Eugene game development kit 8.7.8.<br>
      8.3.1 – Source code synced with Eugene game development kit 8.7.9.<br>
      8.3.2 – Source code synced with Black game development kit 5.7.6.<br>
      8.3.3 – Synchronization timer back-ported from Eugene game development kit 8.8.
    </big>
  </body>
</html>